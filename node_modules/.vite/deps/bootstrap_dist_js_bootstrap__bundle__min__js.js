import { t as __commonJS } from "./chunk-DUEDWNxO.js";

//#region node_modules/bootstrap/dist/js/bootstrap.bundle.min.js
var require_bootstrap_bundle_min = /* @__PURE__ */ __commonJS({ "node_modules/bootstrap/dist/js/bootstrap.bundle.min.js": ((exports, module) => {
	(function(t, e) {
		"object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e();
	})(exports, function() {
		const t = /* @__PURE__ */ new Map(), e = {
			set(e$1, i$1, n$1) {
				t.has(e$1) || t.set(e$1, /* @__PURE__ */ new Map());
				const s$1 = t.get(e$1);
				s$1.has(i$1) || 0 === s$1.size ? s$1.set(i$1, n$1) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s$1.keys())[0]}.`);
			},
			get: (e$1, i$1) => t.has(e$1) && t.get(e$1).get(i$1) || null,
			remove(e$1, i$1) {
				if (!t.has(e$1)) return;
				const n$1 = t.get(e$1);
				n$1.delete(i$1), 0 === n$1.size && t.delete(e$1);
			}
		}, i = "transitionend", n = (t$1) => (t$1 && window.CSS && window.CSS.escape && (t$1 = t$1.replace(/#([^\s"#']+)/g, (t$2, e$1) => `#${CSS.escape(e$1)}`)), t$1), s = (t$1) => null == t$1 ? `${t$1}` : Object.prototype.toString.call(t$1).match(/\s([a-z]+)/i)[1].toLowerCase(), o = (t$1) => {
			t$1.dispatchEvent(new Event(i));
		}, r = (t$1) => !(!t$1 || "object" != typeof t$1) && (void 0 !== t$1.jquery && (t$1 = t$1[0]), void 0 !== t$1.nodeType), a = (t$1) => r(t$1) ? t$1.jquery ? t$1[0] : t$1 : "string" == typeof t$1 && t$1.length > 0 ? document.querySelector(n(t$1)) : null, l = (t$1) => {
			if (!r(t$1) || 0 === t$1.getClientRects().length) return !1;
			const e$1 = "visible" === getComputedStyle(t$1).getPropertyValue("visibility"), i$1 = t$1.closest("details:not([open])");
			if (!i$1) return e$1;
			if (i$1 !== t$1) {
				const e$2 = t$1.closest("summary");
				if (e$2 && e$2.parentNode !== i$1) return !1;
				if (null === e$2) return !1;
			}
			return e$1;
		}, c = (t$1) => !t$1 || t$1.nodeType !== Node.ELEMENT_NODE || !!t$1.classList.contains("disabled") || (void 0 !== t$1.disabled ? t$1.disabled : t$1.hasAttribute("disabled") && "false" !== t$1.getAttribute("disabled")), h = (t$1) => {
			if (!document.documentElement.attachShadow) return null;
			if ("function" == typeof t$1.getRootNode) {
				const e$1 = t$1.getRootNode();
				return e$1 instanceof ShadowRoot ? e$1 : null;
			}
			return t$1 instanceof ShadowRoot ? t$1 : t$1.parentNode ? h(t$1.parentNode) : null;
		}, d = () => {}, u = (t$1) => {
			t$1.offsetHeight;
		}, f = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, p = [], m = () => "rtl" === document.documentElement.dir, g = (t$1) => {
			var e$1 = () => {
				const e$2 = f();
				if (e$2) {
					const i$1 = t$1.NAME, n$1 = e$2.fn[i$1];
					e$2.fn[i$1] = t$1.jQueryInterface, e$2.fn[i$1].Constructor = t$1, e$2.fn[i$1].noConflict = () => (e$2.fn[i$1] = n$1, t$1.jQueryInterface);
				}
			};
			"loading" === document.readyState ? (p.length || document.addEventListener("DOMContentLoaded", () => {
				for (const t$2 of p) t$2();
			}), p.push(e$1)) : e$1();
		}, _ = (t$1, e$1 = [], i$1 = t$1) => "function" == typeof t$1 ? t$1.call(...e$1) : i$1, b = (t$1, e$1, n$1 = !0) => {
			if (!n$1) return void _(t$1);
			const s$1 = ((t$2) => {
				if (!t$2) return 0;
				let { transitionDuration: e$2, transitionDelay: i$1 } = window.getComputedStyle(t$2);
				return Number.parseFloat(e$2) || Number.parseFloat(i$1) ? (e$2 = e$2.split(",")[0], i$1 = i$1.split(",")[0], 1e3 * (Number.parseFloat(e$2) + Number.parseFloat(i$1))) : 0;
			})(e$1) + 5;
			let r$1 = !1;
			const a$1 = ({ target: n$2 }) => {
				n$2 === e$1 && (r$1 = !0, e$1.removeEventListener(i, a$1), _(t$1));
			};
			e$1.addEventListener(i, a$1), setTimeout(() => {
				r$1 || o(e$1);
			}, s$1);
		}, v = (t$1, e$1, i$1, n$1) => {
			const s$1 = t$1.length;
			let o$1 = t$1.indexOf(e$1);
			return -1 === o$1 ? !i$1 && n$1 ? t$1[s$1 - 1] : t$1[0] : (o$1 += i$1 ? 1 : -1, n$1 && (o$1 = (o$1 + s$1) % s$1), t$1[Math.max(0, Math.min(o$1, s$1 - 1))]);
		}, y = /[^.]*(?=\..*)\.|.*/, w = /\..*/, A = /::\d+$/, E = {};
		let T = 1;
		const C = {
			mouseenter: "mouseover",
			mouseleave: "mouseout"
		}, O = new Set([
			"click",
			"dblclick",
			"mouseup",
			"mousedown",
			"contextmenu",
			"mousewheel",
			"DOMMouseScroll",
			"mouseover",
			"mouseout",
			"mousemove",
			"selectstart",
			"selectend",
			"keydown",
			"keypress",
			"keyup",
			"orientationchange",
			"touchstart",
			"touchmove",
			"touchend",
			"touchcancel",
			"pointerdown",
			"pointermove",
			"pointerup",
			"pointerleave",
			"pointercancel",
			"gesturestart",
			"gesturechange",
			"gestureend",
			"focus",
			"blur",
			"change",
			"reset",
			"select",
			"submit",
			"focusin",
			"focusout",
			"load",
			"unload",
			"beforeunload",
			"resize",
			"move",
			"DOMContentLoaded",
			"readystatechange",
			"error",
			"abort",
			"scroll"
		]);
		function x(t$1, e$1) {
			return e$1 && `${e$1}::${T++}` || t$1.uidEvent || T++;
		}
		function k(t$1) {
			const e$1 = x(t$1);
			return t$1.uidEvent = e$1, E[e$1] = E[e$1] || {}, E[e$1];
		}
		function L(t$1, e$1, i$1 = null) {
			return Object.values(t$1).find((t$2) => t$2.callable === e$1 && t$2.delegationSelector === i$1);
		}
		function S(t$1, e$1, i$1) {
			const n$1 = "string" == typeof e$1, s$1 = n$1 ? i$1 : e$1 || i$1;
			let o$1 = N(t$1);
			return O.has(o$1) || (o$1 = t$1), [
				n$1,
				s$1,
				o$1
			];
		}
		function D(t$1, e$1, i$1, n$1, s$1) {
			if ("string" != typeof e$1 || !t$1) return;
			let [o$1, r$1, a$1] = S(e$1, i$1, n$1);
			if (e$1 in C) {
				const t$2 = (t$3) => function(e$2) {
					if (!e$2.relatedTarget || e$2.relatedTarget !== e$2.delegateTarget && !e$2.delegateTarget.contains(e$2.relatedTarget)) return t$3.call(this, e$2);
				};
				r$1 = t$2(r$1);
			}
			const l$1 = k(t$1), c$1 = l$1[a$1] || (l$1[a$1] = {}), h$1 = L(c$1, r$1, o$1 ? i$1 : null);
			if (h$1) return void (h$1.oneOff = h$1.oneOff && s$1);
			const d$1 = x(r$1, e$1.replace(y, "")), u$1 = o$1 ? function(t$2, e$2, i$2) {
				return function n$2(s$2) {
					const o$2 = t$2.querySelectorAll(e$2);
					for (let { target: r$2 } = s$2; r$2 && r$2 !== this; r$2 = r$2.parentNode) for (const a$2 of o$2) if (a$2 === r$2) return j(s$2, { delegateTarget: r$2 }), n$2.oneOff && P.off(t$2, s$2.type, e$2, i$2), i$2.apply(r$2, [s$2]);
				};
			}(t$1, i$1, r$1) : function(t$2, e$2) {
				return function i$2(n$2) {
					return j(n$2, { delegateTarget: t$2 }), i$2.oneOff && P.off(t$2, n$2.type, e$2), e$2.apply(t$2, [n$2]);
				};
			}(t$1, r$1);
			u$1.delegationSelector = o$1 ? i$1 : null, u$1.callable = r$1, u$1.oneOff = s$1, u$1.uidEvent = d$1, c$1[d$1] = u$1, t$1.addEventListener(a$1, u$1, o$1);
		}
		function $(t$1, e$1, i$1, n$1, s$1) {
			const o$1 = L(e$1[i$1], n$1, s$1);
			o$1 && (t$1.removeEventListener(i$1, o$1, Boolean(s$1)), delete e$1[i$1][o$1.uidEvent]);
		}
		function I(t$1, e$1, i$1, n$1) {
			const s$1 = e$1[i$1] || {};
			for (const [o$1, r$1] of Object.entries(s$1)) o$1.includes(n$1) && $(t$1, e$1, i$1, r$1.callable, r$1.delegationSelector);
		}
		function N(t$1) {
			return t$1 = t$1.replace(w, ""), C[t$1] || t$1;
		}
		const P = {
			on(t$1, e$1, i$1, n$1) {
				D(t$1, e$1, i$1, n$1, !1);
			},
			one(t$1, e$1, i$1, n$1) {
				D(t$1, e$1, i$1, n$1, !0);
			},
			off(t$1, e$1, i$1, n$1) {
				if ("string" != typeof e$1 || !t$1) return;
				const [s$1, o$1, r$1] = S(e$1, i$1, n$1), a$1 = r$1 !== e$1, l$1 = k(t$1), c$1 = l$1[r$1] || {}, h$1 = e$1.startsWith(".");
				if (void 0 === o$1) {
					if (h$1) for (const i$2 of Object.keys(l$1)) I(t$1, l$1, i$2, e$1.slice(1));
					for (const [i$2, n$2] of Object.entries(c$1)) {
						const s$2 = i$2.replace(A, "");
						a$1 && !e$1.includes(s$2) || $(t$1, l$1, r$1, n$2.callable, n$2.delegationSelector);
					}
				} else {
					if (!Object.keys(c$1).length) return;
					$(t$1, l$1, r$1, o$1, s$1 ? i$1 : null);
				}
			},
			trigger(t$1, e$1, i$1) {
				if ("string" != typeof e$1 || !t$1) return null;
				const n$1 = f();
				let s$1 = null, o$1 = !0, r$1 = !0, a$1 = !1;
				e$1 !== N(e$1) && n$1 && (s$1 = n$1.Event(e$1, i$1), n$1(t$1).trigger(s$1), o$1 = !s$1.isPropagationStopped(), r$1 = !s$1.isImmediatePropagationStopped(), a$1 = s$1.isDefaultPrevented());
				const l$1 = j(new Event(e$1, {
					bubbles: o$1,
					cancelable: !0
				}), i$1);
				return a$1 && l$1.preventDefault(), r$1 && t$1.dispatchEvent(l$1), l$1.defaultPrevented && s$1 && s$1.preventDefault(), l$1;
			}
		};
		function j(t$1, e$1 = {}) {
			for (const [i$1, n$1] of Object.entries(e$1)) try {
				t$1[i$1] = n$1;
			} catch (e$2) {
				Object.defineProperty(t$1, i$1, {
					configurable: !0,
					get: () => n$1
				});
			}
			return t$1;
		}
		function M(t$1) {
			if ("true" === t$1) return !0;
			if ("false" === t$1) return !1;
			if (t$1 === Number(t$1).toString()) return Number(t$1);
			if ("" === t$1 || "null" === t$1) return null;
			if ("string" != typeof t$1) return t$1;
			try {
				return JSON.parse(decodeURIComponent(t$1));
			} catch (e$1) {
				return t$1;
			}
		}
		function F(t$1) {
			return t$1.replace(/[A-Z]/g, (t$2) => `-${t$2.toLowerCase()}`);
		}
		const H = {
			setDataAttribute(t$1, e$1, i$1) {
				t$1.setAttribute(`data-bs-${F(e$1)}`, i$1);
			},
			removeDataAttribute(t$1, e$1) {
				t$1.removeAttribute(`data-bs-${F(e$1)}`);
			},
			getDataAttributes(t$1) {
				if (!t$1) return {};
				const e$1 = {}, i$1 = Object.keys(t$1.dataset).filter((t$2) => t$2.startsWith("bs") && !t$2.startsWith("bsConfig"));
				for (const n$1 of i$1) {
					let i$2 = n$1.replace(/^bs/, "");
					i$2 = i$2.charAt(0).toLowerCase() + i$2.slice(1), e$1[i$2] = M(t$1.dataset[n$1]);
				}
				return e$1;
			},
			getDataAttribute: (t$1, e$1) => M(t$1.getAttribute(`data-bs-${F(e$1)}`))
		};
		class W {
			static get Default() {
				return {};
			}
			static get DefaultType() {
				return {};
			}
			static get NAME() {
				throw new Error("You have to implement the static method \"NAME\", for each component!");
			}
			_getConfig(t$1) {
				return t$1 = this._mergeConfigObj(t$1), t$1 = this._configAfterMerge(t$1), this._typeCheckConfig(t$1), t$1;
			}
			_configAfterMerge(t$1) {
				return t$1;
			}
			_mergeConfigObj(t$1, e$1) {
				const i$1 = r(e$1) ? H.getDataAttribute(e$1, "config") : {};
				return {
					...this.constructor.Default,
					..."object" == typeof i$1 ? i$1 : {},
					...r(e$1) ? H.getDataAttributes(e$1) : {},
					..."object" == typeof t$1 ? t$1 : {}
				};
			}
			_typeCheckConfig(t$1, e$1 = this.constructor.DefaultType) {
				for (const [i$1, n$1] of Object.entries(e$1)) {
					const e$2 = t$1[i$1], o$1 = r(e$2) ? "element" : s(e$2);
					if (!new RegExp(n$1).test(o$1)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${i$1}" provided type "${o$1}" but expected type "${n$1}".`);
				}
			}
		}
		class B extends W {
			constructor(t$1, i$1) {
				super(), (t$1 = a(t$1)) && (this._element = t$1, this._config = this._getConfig(i$1), e.set(this._element, this.constructor.DATA_KEY, this));
			}
			dispose() {
				e.remove(this._element, this.constructor.DATA_KEY), P.off(this._element, this.constructor.EVENT_KEY);
				for (const t$1 of Object.getOwnPropertyNames(this)) this[t$1] = null;
			}
			_queueCallback(t$1, e$1, i$1 = !0) {
				b(t$1, e$1, i$1);
			}
			_getConfig(t$1) {
				return t$1 = this._mergeConfigObj(t$1, this._element), t$1 = this._configAfterMerge(t$1), this._typeCheckConfig(t$1), t$1;
			}
			static getInstance(t$1) {
				return e.get(a(t$1), this.DATA_KEY);
			}
			static getOrCreateInstance(t$1, e$1 = {}) {
				return this.getInstance(t$1) || new this(t$1, "object" == typeof e$1 ? e$1 : null);
			}
			static get VERSION() {
				return "5.3.8";
			}
			static get DATA_KEY() {
				return `bs.${this.NAME}`;
			}
			static get EVENT_KEY() {
				return `.${this.DATA_KEY}`;
			}
			static eventName(t$1) {
				return `${t$1}${this.EVENT_KEY}`;
			}
		}
		const z = (t$1) => {
			let e$1 = t$1.getAttribute("data-bs-target");
			if (!e$1 || "#" === e$1) {
				let i$1 = t$1.getAttribute("href");
				if (!i$1 || !i$1.includes("#") && !i$1.startsWith(".")) return null;
				i$1.includes("#") && !i$1.startsWith("#") && (i$1 = `#${i$1.split("#")[1]}`), e$1 = i$1 && "#" !== i$1 ? i$1.trim() : null;
			}
			return e$1 ? e$1.split(",").map((t$2) => n(t$2)).join(",") : null;
		}, R = {
			find: (t$1, e$1 = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e$1, t$1)),
			findOne: (t$1, e$1 = document.documentElement) => Element.prototype.querySelector.call(e$1, t$1),
			children: (t$1, e$1) => [].concat(...t$1.children).filter((t$2) => t$2.matches(e$1)),
			parents(t$1, e$1) {
				const i$1 = [];
				let n$1 = t$1.parentNode.closest(e$1);
				for (; n$1;) i$1.push(n$1), n$1 = n$1.parentNode.closest(e$1);
				return i$1;
			},
			prev(t$1, e$1) {
				let i$1 = t$1.previousElementSibling;
				for (; i$1;) {
					if (i$1.matches(e$1)) return [i$1];
					i$1 = i$1.previousElementSibling;
				}
				return [];
			},
			next(t$1, e$1) {
				let i$1 = t$1.nextElementSibling;
				for (; i$1;) {
					if (i$1.matches(e$1)) return [i$1];
					i$1 = i$1.nextElementSibling;
				}
				return [];
			},
			focusableChildren(t$1) {
				const e$1 = [
					"a",
					"button",
					"input",
					"textarea",
					"select",
					"details",
					"[tabindex]",
					"[contenteditable=\"true\"]"
				].map((t$2) => `${t$2}:not([tabindex^="-"])`).join(",");
				return this.find(e$1, t$1).filter((t$2) => !c(t$2) && l(t$2));
			},
			getSelectorFromElement(t$1) {
				const e$1 = z(t$1);
				return e$1 && R.findOne(e$1) ? e$1 : null;
			},
			getElementFromSelector(t$1) {
				const e$1 = z(t$1);
				return e$1 ? R.findOne(e$1) : null;
			},
			getMultipleElementsFromSelector(t$1) {
				const e$1 = z(t$1);
				return e$1 ? R.find(e$1) : [];
			}
		}, q = (t$1, e$1 = "hide") => {
			const i$1 = `click.dismiss${t$1.EVENT_KEY}`, n$1 = t$1.NAME;
			P.on(document, i$1, `[data-bs-dismiss="${n$1}"]`, function(i$2) {
				if (["A", "AREA"].includes(this.tagName) && i$2.preventDefault(), c(this)) return;
				const s$1 = R.getElementFromSelector(this) || this.closest(`.${n$1}`);
				t$1.getOrCreateInstance(s$1)[e$1]();
			});
		}, V = ".bs.alert", K = `close${V}`, Q = `closed${V}`;
		class X extends B {
			static get NAME() {
				return "alert";
			}
			close() {
				if (P.trigger(this._element, K).defaultPrevented) return;
				this._element.classList.remove("show");
				const t$1 = this._element.classList.contains("fade");
				this._queueCallback(() => this._destroyElement(), this._element, t$1);
			}
			_destroyElement() {
				this._element.remove(), P.trigger(this._element, Q), this.dispose();
			}
			static jQueryInterface(t$1) {
				return this.each(function() {
					const e$1 = X.getOrCreateInstance(this);
					if ("string" == typeof t$1) {
						if (void 0 === e$1[t$1] || t$1.startsWith("_") || "constructor" === t$1) throw new TypeError(`No method named "${t$1}"`);
						e$1[t$1](this);
					}
				});
			}
		}
		q(X, "close"), g(X);
		const Y = "[data-bs-toggle=\"button\"]";
		class U extends B {
			static get NAME() {
				return "button";
			}
			toggle() {
				this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
			}
			static jQueryInterface(t$1) {
				return this.each(function() {
					const e$1 = U.getOrCreateInstance(this);
					"toggle" === t$1 && e$1[t$1]();
				});
			}
		}
		P.on(document, "click.bs.button.data-api", Y, (t$1) => {
			t$1.preventDefault();
			const e$1 = t$1.target.closest(Y);
			U.getOrCreateInstance(e$1).toggle();
		}), g(U);
		const G = ".bs.swipe", J = `touchstart${G}`, Z = `touchmove${G}`, tt = `touchend${G}`, et = `pointerdown${G}`, it = `pointerup${G}`, nt = {
			endCallback: null,
			leftCallback: null,
			rightCallback: null
		}, st = {
			endCallback: "(function|null)",
			leftCallback: "(function|null)",
			rightCallback: "(function|null)"
		};
		class ot extends W {
			constructor(t$1, e$1) {
				super(), this._element = t$1, t$1 && ot.isSupported() && (this._config = this._getConfig(e$1), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents());
			}
			static get Default() {
				return nt;
			}
			static get DefaultType() {
				return st;
			}
			static get NAME() {
				return "swipe";
			}
			dispose() {
				P.off(this._element, G);
			}
			_start(t$1) {
				this._supportPointerEvents ? this._eventIsPointerPenTouch(t$1) && (this._deltaX = t$1.clientX) : this._deltaX = t$1.touches[0].clientX;
			}
			_end(t$1) {
				this._eventIsPointerPenTouch(t$1) && (this._deltaX = t$1.clientX - this._deltaX), this._handleSwipe(), _(this._config.endCallback);
			}
			_move(t$1) {
				this._deltaX = t$1.touches && t$1.touches.length > 1 ? 0 : t$1.touches[0].clientX - this._deltaX;
			}
			_handleSwipe() {
				const t$1 = Math.abs(this._deltaX);
				if (t$1 <= 40) return;
				const e$1 = t$1 / this._deltaX;
				this._deltaX = 0, e$1 && _(e$1 > 0 ? this._config.rightCallback : this._config.leftCallback);
			}
			_initEvents() {
				this._supportPointerEvents ? (P.on(this._element, et, (t$1) => this._start(t$1)), P.on(this._element, it, (t$1) => this._end(t$1)), this._element.classList.add("pointer-event")) : (P.on(this._element, J, (t$1) => this._start(t$1)), P.on(this._element, Z, (t$1) => this._move(t$1)), P.on(this._element, tt, (t$1) => this._end(t$1)));
			}
			_eventIsPointerPenTouch(t$1) {
				return this._supportPointerEvents && ("pen" === t$1.pointerType || "touch" === t$1.pointerType);
			}
			static isSupported() {
				return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
			}
		}
		const rt = ".bs.carousel", at = ".data-api", lt = "ArrowLeft", ct = "ArrowRight", ht = "next", dt = "prev", ut = "left", ft = "right", pt = `slide${rt}`, mt = `slid${rt}`, gt = `keydown${rt}`, _t = `mouseenter${rt}`, bt = `mouseleave${rt}`, vt = `dragstart${rt}`, yt = `load${rt}${at}`, wt = `click${rt}${at}`, At = "carousel", Et = "active", Tt = ".active", Ct = ".carousel-item", Ot = Tt + Ct, xt = {
			[lt]: ft,
			[ct]: ut
		}, kt = {
			interval: 5e3,
			keyboard: !0,
			pause: "hover",
			ride: !1,
			touch: !0,
			wrap: !0
		}, Lt = {
			interval: "(number|boolean)",
			keyboard: "boolean",
			pause: "(string|boolean)",
			ride: "(boolean|string)",
			touch: "boolean",
			wrap: "boolean"
		};
		class St extends B {
			constructor(t$1, e$1) {
				super(t$1, e$1), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = R.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === At && this.cycle();
			}
			static get Default() {
				return kt;
			}
			static get DefaultType() {
				return Lt;
			}
			static get NAME() {
				return "carousel";
			}
			next() {
				this._slide(ht);
			}
			nextWhenVisible() {
				!document.hidden && l(this._element) && this.next();
			}
			prev() {
				this._slide(dt);
			}
			pause() {
				this._isSliding && o(this._element), this._clearInterval();
			}
			cycle() {
				this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
			}
			_maybeEnableCycle() {
				this._config.ride && (this._isSliding ? P.one(this._element, mt, () => this.cycle()) : this.cycle());
			}
			to(t$1) {
				const e$1 = this._getItems();
				if (t$1 > e$1.length - 1 || t$1 < 0) return;
				if (this._isSliding) return void P.one(this._element, mt, () => this.to(t$1));
				const i$1 = this._getItemIndex(this._getActive());
				if (i$1 === t$1) return;
				const n$1 = t$1 > i$1 ? ht : dt;
				this._slide(n$1, e$1[t$1]);
			}
			dispose() {
				this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
			}
			_configAfterMerge(t$1) {
				return t$1.defaultInterval = t$1.interval, t$1;
			}
			_addEventListeners() {
				this._config.keyboard && P.on(this._element, gt, (t$1) => this._keydown(t$1)), "hover" === this._config.pause && (P.on(this._element, _t, () => this.pause()), P.on(this._element, bt, () => this._maybeEnableCycle())), this._config.touch && ot.isSupported() && this._addTouchEventListeners();
			}
			_addTouchEventListeners() {
				for (const t$1 of R.find(".carousel-item img", this._element)) P.on(t$1, vt, (t$2) => t$2.preventDefault());
				this._swipeHelper = new ot(this._element, {
					leftCallback: () => this._slide(this._directionToOrder(ut)),
					rightCallback: () => this._slide(this._directionToOrder(ft)),
					endCallback: () => {
						"hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval));
					}
				});
			}
			_keydown(t$1) {
				if (/input|textarea/i.test(t$1.target.tagName)) return;
				const e$1 = xt[t$1.key];
				e$1 && (t$1.preventDefault(), this._slide(this._directionToOrder(e$1)));
			}
			_getItemIndex(t$1) {
				return this._getItems().indexOf(t$1);
			}
			_setActiveIndicatorElement(t$1) {
				if (!this._indicatorsElement) return;
				const e$1 = R.findOne(Tt, this._indicatorsElement);
				e$1.classList.remove(Et), e$1.removeAttribute("aria-current");
				const i$1 = R.findOne(`[data-bs-slide-to="${t$1}"]`, this._indicatorsElement);
				i$1 && (i$1.classList.add(Et), i$1.setAttribute("aria-current", "true"));
			}
			_updateInterval() {
				const t$1 = this._activeElement || this._getActive();
				if (!t$1) return;
				const e$1 = Number.parseInt(t$1.getAttribute("data-bs-interval"), 10);
				this._config.interval = e$1 || this._config.defaultInterval;
			}
			_slide(t$1, e$1 = null) {
				if (this._isSliding) return;
				const i$1 = this._getActive(), n$1 = t$1 === ht, s$1 = e$1 || v(this._getItems(), i$1, n$1, this._config.wrap);
				if (s$1 === i$1) return;
				const o$1 = this._getItemIndex(s$1), r$1 = (e$2) => P.trigger(this._element, e$2, {
					relatedTarget: s$1,
					direction: this._orderToDirection(t$1),
					from: this._getItemIndex(i$1),
					to: o$1
				});
				if (r$1(pt).defaultPrevented) return;
				if (!i$1 || !s$1) return;
				const a$1 = Boolean(this._interval);
				this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o$1), this._activeElement = s$1;
				const l$1 = n$1 ? "carousel-item-start" : "carousel-item-end", c$1 = n$1 ? "carousel-item-next" : "carousel-item-prev";
				s$1.classList.add(c$1), u(s$1), i$1.classList.add(l$1), s$1.classList.add(l$1), this._queueCallback(() => {
					s$1.classList.remove(l$1, c$1), s$1.classList.add(Et), i$1.classList.remove(Et, c$1, l$1), this._isSliding = !1, r$1(mt);
				}, i$1, this._isAnimated()), a$1 && this.cycle();
			}
			_isAnimated() {
				return this._element.classList.contains("slide");
			}
			_getActive() {
				return R.findOne(Ot, this._element);
			}
			_getItems() {
				return R.find(Ct, this._element);
			}
			_clearInterval() {
				this._interval && (clearInterval(this._interval), this._interval = null);
			}
			_directionToOrder(t$1) {
				return m() ? t$1 === ut ? dt : ht : t$1 === ut ? ht : dt;
			}
			_orderToDirection(t$1) {
				return m() ? t$1 === dt ? ut : ft : t$1 === dt ? ft : ut;
			}
			static jQueryInterface(t$1) {
				return this.each(function() {
					const e$1 = St.getOrCreateInstance(this, t$1);
					if ("number" != typeof t$1) {
						if ("string" == typeof t$1) {
							if (void 0 === e$1[t$1] || t$1.startsWith("_") || "constructor" === t$1) throw new TypeError(`No method named "${t$1}"`);
							e$1[t$1]();
						}
					} else e$1.to(t$1);
				});
			}
		}
		P.on(document, wt, "[data-bs-slide], [data-bs-slide-to]", function(t$1) {
			const e$1 = R.getElementFromSelector(this);
			if (!e$1 || !e$1.classList.contains(At)) return;
			t$1.preventDefault();
			const i$1 = St.getOrCreateInstance(e$1), n$1 = this.getAttribute("data-bs-slide-to");
			n$1 ? (i$1.to(n$1), i$1._maybeEnableCycle()) : "next" === H.getDataAttribute(this, "slide") ? (i$1.next(), i$1._maybeEnableCycle()) : (i$1.prev(), i$1._maybeEnableCycle());
		}), P.on(window, yt, () => {
			const t$1 = R.find("[data-bs-ride=\"carousel\"]");
			for (const e$1 of t$1) St.getOrCreateInstance(e$1);
		}), g(St);
		const Dt = ".bs.collapse", $t = `show${Dt}`, It = `shown${Dt}`, Nt = `hide${Dt}`, Pt = `hidden${Dt}`, jt = `click${Dt}.data-api`, Mt = "show", Ft = "collapse", Ht = "collapsing", Wt = `:scope .${Ft} .${Ft}`, Bt = "[data-bs-toggle=\"collapse\"]", zt = {
			parent: null,
			toggle: !0
		}, Rt = {
			parent: "(null|element)",
			toggle: "boolean"
		};
		class qt extends B {
			constructor(t$1, e$1) {
				super(t$1, e$1), this._isTransitioning = !1, this._triggerArray = [];
				const i$1 = R.find(Bt);
				for (const t$2 of i$1) {
					const e$2 = R.getSelectorFromElement(t$2), i$2 = R.find(e$2).filter((t$3) => t$3 === this._element);
					null !== e$2 && i$2.length && this._triggerArray.push(t$2);
				}
				this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
			}
			static get Default() {
				return zt;
			}
			static get DefaultType() {
				return Rt;
			}
			static get NAME() {
				return "collapse";
			}
			toggle() {
				this._isShown() ? this.hide() : this.show();
			}
			show() {
				if (this._isTransitioning || this._isShown()) return;
				let t$1 = [];
				if (this._config.parent && (t$1 = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t$2) => t$2 !== this._element).map((t$2) => qt.getOrCreateInstance(t$2, { toggle: !1 }))), t$1.length && t$1[0]._isTransitioning) return;
				if (P.trigger(this._element, $t).defaultPrevented) return;
				for (const e$2 of t$1) e$2.hide();
				const e$1 = this._getDimension();
				this._element.classList.remove(Ft), this._element.classList.add(Ht), this._element.style[e$1] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
				const i$1 = `scroll${e$1[0].toUpperCase() + e$1.slice(1)}`;
				this._queueCallback(() => {
					this._isTransitioning = !1, this._element.classList.remove(Ht), this._element.classList.add(Ft, Mt), this._element.style[e$1] = "", P.trigger(this._element, It);
				}, this._element, !0), this._element.style[e$1] = `${this._element[i$1]}px`;
			}
			hide() {
				if (this._isTransitioning || !this._isShown()) return;
				if (P.trigger(this._element, Nt).defaultPrevented) return;
				const t$1 = this._getDimension();
				this._element.style[t$1] = `${this._element.getBoundingClientRect()[t$1]}px`, u(this._element), this._element.classList.add(Ht), this._element.classList.remove(Ft, Mt);
				for (const t$2 of this._triggerArray) {
					const e$1 = R.getElementFromSelector(t$2);
					e$1 && !this._isShown(e$1) && this._addAriaAndCollapsedClass([t$2], !1);
				}
				this._isTransitioning = !0, this._element.style[t$1] = "", this._queueCallback(() => {
					this._isTransitioning = !1, this._element.classList.remove(Ht), this._element.classList.add(Ft), P.trigger(this._element, Pt);
				}, this._element, !0);
			}
			_isShown(t$1 = this._element) {
				return t$1.classList.contains(Mt);
			}
			_configAfterMerge(t$1) {
				return t$1.toggle = Boolean(t$1.toggle), t$1.parent = a(t$1.parent), t$1;
			}
			_getDimension() {
				return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
			}
			_initializeChildren() {
				if (!this._config.parent) return;
				const t$1 = this._getFirstLevelChildren(Bt);
				for (const e$1 of t$1) {
					const t$2 = R.getElementFromSelector(e$1);
					t$2 && this._addAriaAndCollapsedClass([e$1], this._isShown(t$2));
				}
			}
			_getFirstLevelChildren(t$1) {
				const e$1 = R.find(Wt, this._config.parent);
				return R.find(t$1, this._config.parent).filter((t$2) => !e$1.includes(t$2));
			}
			_addAriaAndCollapsedClass(t$1, e$1) {
				if (t$1.length) for (const i$1 of t$1) i$1.classList.toggle("collapsed", !e$1), i$1.setAttribute("aria-expanded", e$1);
			}
			static jQueryInterface(t$1) {
				const e$1 = {};
				return "string" == typeof t$1 && /show|hide/.test(t$1) && (e$1.toggle = !1), this.each(function() {
					const i$1 = qt.getOrCreateInstance(this, e$1);
					if ("string" == typeof t$1) {
						if (void 0 === i$1[t$1]) throw new TypeError(`No method named "${t$1}"`);
						i$1[t$1]();
					}
				});
			}
		}
		P.on(document, jt, Bt, function(t$1) {
			("A" === t$1.target.tagName || t$1.delegateTarget && "A" === t$1.delegateTarget.tagName) && t$1.preventDefault();
			for (const t$2 of R.getMultipleElementsFromSelector(this)) qt.getOrCreateInstance(t$2, { toggle: !1 }).toggle();
		}), g(qt);
		var Vt = "top", Kt = "bottom", Qt = "right", Xt = "left", Yt = "auto", Ut = [
			Vt,
			Kt,
			Qt,
			Xt
		], Gt = "start", Jt = "end", Zt = "clippingParents", te = "viewport", ee = "popper", ie = "reference", ne = Ut.reduce(function(t$1, e$1) {
			return t$1.concat([e$1 + "-" + Gt, e$1 + "-" + Jt]);
		}, []), se = [].concat(Ut, [Yt]).reduce(function(t$1, e$1) {
			return t$1.concat([
				e$1,
				e$1 + "-" + Gt,
				e$1 + "-" + Jt
			]);
		}, []), oe = "beforeRead", re = "read", ae = "afterRead", le = "beforeMain", ce = "main", he = "afterMain", de = "beforeWrite", ue = "write", fe = "afterWrite", pe = [
			oe,
			re,
			ae,
			le,
			ce,
			he,
			de,
			ue,
			fe
		];
		function me(t$1) {
			return t$1 ? (t$1.nodeName || "").toLowerCase() : null;
		}
		function ge(t$1) {
			if (null == t$1) return window;
			if ("[object Window]" !== t$1.toString()) {
				var e$1 = t$1.ownerDocument;
				return e$1 && e$1.defaultView || window;
			}
			return t$1;
		}
		function _e(t$1) {
			return t$1 instanceof ge(t$1).Element || t$1 instanceof Element;
		}
		function be(t$1) {
			return t$1 instanceof ge(t$1).HTMLElement || t$1 instanceof HTMLElement;
		}
		function ve(t$1) {
			return "undefined" != typeof ShadowRoot && (t$1 instanceof ge(t$1).ShadowRoot || t$1 instanceof ShadowRoot);
		}
		const ye = {
			name: "applyStyles",
			enabled: !0,
			phase: "write",
			fn: function(t$1) {
				var e$1 = t$1.state;
				Object.keys(e$1.elements).forEach(function(t$2) {
					var i$1 = e$1.styles[t$2] || {}, n$1 = e$1.attributes[t$2] || {}, s$1 = e$1.elements[t$2];
					be(s$1) && me(s$1) && (Object.assign(s$1.style, i$1), Object.keys(n$1).forEach(function(t$3) {
						var e$2 = n$1[t$3];
						!1 === e$2 ? s$1.removeAttribute(t$3) : s$1.setAttribute(t$3, !0 === e$2 ? "" : e$2);
					}));
				});
			},
			effect: function(t$1) {
				var e$1 = t$1.state, i$1 = {
					popper: {
						position: e$1.options.strategy,
						left: "0",
						top: "0",
						margin: "0"
					},
					arrow: { position: "absolute" },
					reference: {}
				};
				return Object.assign(e$1.elements.popper.style, i$1.popper), e$1.styles = i$1, e$1.elements.arrow && Object.assign(e$1.elements.arrow.style, i$1.arrow), function() {
					Object.keys(e$1.elements).forEach(function(t$2) {
						var n$1 = e$1.elements[t$2], s$1 = e$1.attributes[t$2] || {}, o$1 = Object.keys(e$1.styles.hasOwnProperty(t$2) ? e$1.styles[t$2] : i$1[t$2]).reduce(function(t$3, e$2) {
							return t$3[e$2] = "", t$3;
						}, {});
						be(n$1) && me(n$1) && (Object.assign(n$1.style, o$1), Object.keys(s$1).forEach(function(t$3) {
							n$1.removeAttribute(t$3);
						}));
					});
				};
			},
			requires: ["computeStyles"]
		};
		function we(t$1) {
			return t$1.split("-")[0];
		}
		var Ae = Math.max, Ee = Math.min, Te = Math.round;
		function Ce() {
			var t$1 = navigator.userAgentData;
			return null != t$1 && t$1.brands && Array.isArray(t$1.brands) ? t$1.brands.map(function(t$2) {
				return t$2.brand + "/" + t$2.version;
			}).join(" ") : navigator.userAgent;
		}
		function Oe() {
			return !/^((?!chrome|android).)*safari/i.test(Ce());
		}
		function xe(t$1, e$1, i$1) {
			void 0 === e$1 && (e$1 = !1), void 0 === i$1 && (i$1 = !1);
			var n$1 = t$1.getBoundingClientRect(), s$1 = 1, o$1 = 1;
			e$1 && be(t$1) && (s$1 = t$1.offsetWidth > 0 && Te(n$1.width) / t$1.offsetWidth || 1, o$1 = t$1.offsetHeight > 0 && Te(n$1.height) / t$1.offsetHeight || 1);
			var r$1 = (_e(t$1) ? ge(t$1) : window).visualViewport, a$1 = !Oe() && i$1, l$1 = (n$1.left + (a$1 && r$1 ? r$1.offsetLeft : 0)) / s$1, c$1 = (n$1.top + (a$1 && r$1 ? r$1.offsetTop : 0)) / o$1, h$1 = n$1.width / s$1, d$1 = n$1.height / o$1;
			return {
				width: h$1,
				height: d$1,
				top: c$1,
				right: l$1 + h$1,
				bottom: c$1 + d$1,
				left: l$1,
				x: l$1,
				y: c$1
			};
		}
		function ke(t$1) {
			var e$1 = xe(t$1), i$1 = t$1.offsetWidth, n$1 = t$1.offsetHeight;
			return Math.abs(e$1.width - i$1) <= 1 && (i$1 = e$1.width), Math.abs(e$1.height - n$1) <= 1 && (n$1 = e$1.height), {
				x: t$1.offsetLeft,
				y: t$1.offsetTop,
				width: i$1,
				height: n$1
			};
		}
		function Le(t$1, e$1) {
			var i$1 = e$1.getRootNode && e$1.getRootNode();
			if (t$1.contains(e$1)) return !0;
			if (i$1 && ve(i$1)) {
				var n$1 = e$1;
				do {
					if (n$1 && t$1.isSameNode(n$1)) return !0;
					n$1 = n$1.parentNode || n$1.host;
				} while (n$1);
			}
			return !1;
		}
		function Se(t$1) {
			return ge(t$1).getComputedStyle(t$1);
		}
		function De(t$1) {
			return [
				"table",
				"td",
				"th"
			].indexOf(me(t$1)) >= 0;
		}
		function $e(t$1) {
			return ((_e(t$1) ? t$1.ownerDocument : t$1.document) || window.document).documentElement;
		}
		function Ie(t$1) {
			return "html" === me(t$1) ? t$1 : t$1.assignedSlot || t$1.parentNode || (ve(t$1) ? t$1.host : null) || $e(t$1);
		}
		function Ne(t$1) {
			return be(t$1) && "fixed" !== Se(t$1).position ? t$1.offsetParent : null;
		}
		function Pe(t$1) {
			for (var e$1 = ge(t$1), i$1 = Ne(t$1); i$1 && De(i$1) && "static" === Se(i$1).position;) i$1 = Ne(i$1);
			return i$1 && ("html" === me(i$1) || "body" === me(i$1) && "static" === Se(i$1).position) ? e$1 : i$1 || function(t$2) {
				var e$2 = /firefox/i.test(Ce());
				if (/Trident/i.test(Ce()) && be(t$2) && "fixed" === Se(t$2).position) return null;
				var i$2 = Ie(t$2);
				for (ve(i$2) && (i$2 = i$2.host); be(i$2) && ["html", "body"].indexOf(me(i$2)) < 0;) {
					var n$1 = Se(i$2);
					if ("none" !== n$1.transform || "none" !== n$1.perspective || "paint" === n$1.contain || -1 !== ["transform", "perspective"].indexOf(n$1.willChange) || e$2 && "filter" === n$1.willChange || e$2 && n$1.filter && "none" !== n$1.filter) return i$2;
					i$2 = i$2.parentNode;
				}
				return null;
			}(t$1) || e$1;
		}
		function je(t$1) {
			return ["top", "bottom"].indexOf(t$1) >= 0 ? "x" : "y";
		}
		function Me(t$1, e$1, i$1) {
			return Ae(t$1, Ee(e$1, i$1));
		}
		function Fe(t$1) {
			return Object.assign({}, {
				top: 0,
				right: 0,
				bottom: 0,
				left: 0
			}, t$1);
		}
		function He(t$1, e$1) {
			return e$1.reduce(function(e$2, i$1) {
				return e$2[i$1] = t$1, e$2;
			}, {});
		}
		const We = {
			name: "arrow",
			enabled: !0,
			phase: "main",
			fn: function(t$1) {
				var e$1, i$1 = t$1.state, n$1 = t$1.name, s$1 = t$1.options, o$1 = i$1.elements.arrow, r$1 = i$1.modifiersData.popperOffsets, a$1 = we(i$1.placement), l$1 = je(a$1), c$1 = [Xt, Qt].indexOf(a$1) >= 0 ? "height" : "width";
				if (o$1 && r$1) {
					var h$1 = function(t$2, e$2) {
						return Fe("number" != typeof (t$2 = "function" == typeof t$2 ? t$2(Object.assign({}, e$2.rects, { placement: e$2.placement })) : t$2) ? t$2 : He(t$2, Ut));
					}(s$1.padding, i$1), d$1 = ke(o$1), u$1 = "y" === l$1 ? Vt : Xt, f$1 = "y" === l$1 ? Kt : Qt, p$1 = i$1.rects.reference[c$1] + i$1.rects.reference[l$1] - r$1[l$1] - i$1.rects.popper[c$1], m$1 = r$1[l$1] - i$1.rects.reference[l$1], g$1 = Pe(o$1), _$1 = g$1 ? "y" === l$1 ? g$1.clientHeight || 0 : g$1.clientWidth || 0 : 0, b$1 = p$1 / 2 - m$1 / 2, v$1 = h$1[u$1], y$1 = _$1 - d$1[c$1] - h$1[f$1], w$1 = _$1 / 2 - d$1[c$1] / 2 + b$1, A$1 = Me(v$1, w$1, y$1), E$1 = l$1;
					i$1.modifiersData[n$1] = ((e$1 = {})[E$1] = A$1, e$1.centerOffset = A$1 - w$1, e$1);
				}
			},
			effect: function(t$1) {
				var e$1 = t$1.state, i$1 = t$1.options.element, n$1 = void 0 === i$1 ? "[data-popper-arrow]" : i$1;
				null != n$1 && ("string" != typeof n$1 || (n$1 = e$1.elements.popper.querySelector(n$1))) && Le(e$1.elements.popper, n$1) && (e$1.elements.arrow = n$1);
			},
			requires: ["popperOffsets"],
			requiresIfExists: ["preventOverflow"]
		};
		function Be(t$1) {
			return t$1.split("-")[1];
		}
		var ze = {
			top: "auto",
			right: "auto",
			bottom: "auto",
			left: "auto"
		};
		function Re(t$1) {
			var e$1, i$1 = t$1.popper, n$1 = t$1.popperRect, s$1 = t$1.placement, o$1 = t$1.variation, r$1 = t$1.offsets, a$1 = t$1.position, l$1 = t$1.gpuAcceleration, c$1 = t$1.adaptive, h$1 = t$1.roundOffsets, d$1 = t$1.isFixed, u$1 = r$1.x, f$1 = void 0 === u$1 ? 0 : u$1, p$1 = r$1.y, m$1 = void 0 === p$1 ? 0 : p$1, g$1 = "function" == typeof h$1 ? h$1({
				x: f$1,
				y: m$1
			}) : {
				x: f$1,
				y: m$1
			};
			f$1 = g$1.x, m$1 = g$1.y;
			var _$1 = r$1.hasOwnProperty("x"), b$1 = r$1.hasOwnProperty("y"), v$1 = Xt, y$1 = Vt, w$1 = window;
			if (c$1) {
				var A$1 = Pe(i$1), E$1 = "clientHeight", T$1 = "clientWidth";
				A$1 === ge(i$1) && "static" !== Se(A$1 = $e(i$1)).position && "absolute" === a$1 && (E$1 = "scrollHeight", T$1 = "scrollWidth"), (s$1 === Vt || (s$1 === Xt || s$1 === Qt) && o$1 === Jt) && (y$1 = Kt, m$1 -= (d$1 && A$1 === w$1 && w$1.visualViewport ? w$1.visualViewport.height : A$1[E$1]) - n$1.height, m$1 *= l$1 ? 1 : -1), s$1 !== Xt && (s$1 !== Vt && s$1 !== Kt || o$1 !== Jt) || (v$1 = Qt, f$1 -= (d$1 && A$1 === w$1 && w$1.visualViewport ? w$1.visualViewport.width : A$1[T$1]) - n$1.width, f$1 *= l$1 ? 1 : -1);
			}
			var C$1, O$1 = Object.assign({ position: a$1 }, c$1 && ze), x$1 = !0 === h$1 ? function(t$2, e$2) {
				var i$2 = t$2.x, n$2 = t$2.y, s$2 = e$2.devicePixelRatio || 1;
				return {
					x: Te(i$2 * s$2) / s$2 || 0,
					y: Te(n$2 * s$2) / s$2 || 0
				};
			}({
				x: f$1,
				y: m$1
			}, ge(i$1)) : {
				x: f$1,
				y: m$1
			};
			return f$1 = x$1.x, m$1 = x$1.y, l$1 ? Object.assign({}, O$1, ((C$1 = {})[y$1] = b$1 ? "0" : "", C$1[v$1] = _$1 ? "0" : "", C$1.transform = (w$1.devicePixelRatio || 1) <= 1 ? "translate(" + f$1 + "px, " + m$1 + "px)" : "translate3d(" + f$1 + "px, " + m$1 + "px, 0)", C$1)) : Object.assign({}, O$1, ((e$1 = {})[y$1] = b$1 ? m$1 + "px" : "", e$1[v$1] = _$1 ? f$1 + "px" : "", e$1.transform = "", e$1));
		}
		const qe = {
			name: "computeStyles",
			enabled: !0,
			phase: "beforeWrite",
			fn: function(t$1) {
				var e$1 = t$1.state, i$1 = t$1.options, n$1 = i$1.gpuAcceleration, s$1 = void 0 === n$1 || n$1, o$1 = i$1.adaptive, r$1 = void 0 === o$1 || o$1, a$1 = i$1.roundOffsets, l$1 = void 0 === a$1 || a$1, c$1 = {
					placement: we(e$1.placement),
					variation: Be(e$1.placement),
					popper: e$1.elements.popper,
					popperRect: e$1.rects.popper,
					gpuAcceleration: s$1,
					isFixed: "fixed" === e$1.options.strategy
				};
				null != e$1.modifiersData.popperOffsets && (e$1.styles.popper = Object.assign({}, e$1.styles.popper, Re(Object.assign({}, c$1, {
					offsets: e$1.modifiersData.popperOffsets,
					position: e$1.options.strategy,
					adaptive: r$1,
					roundOffsets: l$1
				})))), null != e$1.modifiersData.arrow && (e$1.styles.arrow = Object.assign({}, e$1.styles.arrow, Re(Object.assign({}, c$1, {
					offsets: e$1.modifiersData.arrow,
					position: "absolute",
					adaptive: !1,
					roundOffsets: l$1
				})))), e$1.attributes.popper = Object.assign({}, e$1.attributes.popper, { "data-popper-placement": e$1.placement });
			},
			data: {}
		};
		var Ve = { passive: !0 };
		const Ke = {
			name: "eventListeners",
			enabled: !0,
			phase: "write",
			fn: function() {},
			effect: function(t$1) {
				var e$1 = t$1.state, i$1 = t$1.instance, n$1 = t$1.options, s$1 = n$1.scroll, o$1 = void 0 === s$1 || s$1, r$1 = n$1.resize, a$1 = void 0 === r$1 || r$1, l$1 = ge(e$1.elements.popper), c$1 = [].concat(e$1.scrollParents.reference, e$1.scrollParents.popper);
				return o$1 && c$1.forEach(function(t$2) {
					t$2.addEventListener("scroll", i$1.update, Ve);
				}), a$1 && l$1.addEventListener("resize", i$1.update, Ve), function() {
					o$1 && c$1.forEach(function(t$2) {
						t$2.removeEventListener("scroll", i$1.update, Ve);
					}), a$1 && l$1.removeEventListener("resize", i$1.update, Ve);
				};
			},
			data: {}
		};
		var Qe = {
			left: "right",
			right: "left",
			bottom: "top",
			top: "bottom"
		};
		function Xe(t$1) {
			return t$1.replace(/left|right|bottom|top/g, function(t$2) {
				return Qe[t$2];
			});
		}
		var Ye = {
			start: "end",
			end: "start"
		};
		function Ue(t$1) {
			return t$1.replace(/start|end/g, function(t$2) {
				return Ye[t$2];
			});
		}
		function Ge(t$1) {
			var e$1 = ge(t$1);
			return {
				scrollLeft: e$1.pageXOffset,
				scrollTop: e$1.pageYOffset
			};
		}
		function Je(t$1) {
			return xe($e(t$1)).left + Ge(t$1).scrollLeft;
		}
		function Ze(t$1) {
			var e$1 = Se(t$1), i$1 = e$1.overflow, n$1 = e$1.overflowX, s$1 = e$1.overflowY;
			return /auto|scroll|overlay|hidden/.test(i$1 + s$1 + n$1);
		}
		function ti(t$1) {
			return [
				"html",
				"body",
				"#document"
			].indexOf(me(t$1)) >= 0 ? t$1.ownerDocument.body : be(t$1) && Ze(t$1) ? t$1 : ti(Ie(t$1));
		}
		function ei(t$1, e$1) {
			var i$1;
			void 0 === e$1 && (e$1 = []);
			var n$1 = ti(t$1), s$1 = n$1 === (null == (i$1 = t$1.ownerDocument) ? void 0 : i$1.body), o$1 = ge(n$1), r$1 = s$1 ? [o$1].concat(o$1.visualViewport || [], Ze(n$1) ? n$1 : []) : n$1, a$1 = e$1.concat(r$1);
			return s$1 ? a$1 : a$1.concat(ei(Ie(r$1)));
		}
		function ii(t$1) {
			return Object.assign({}, t$1, {
				left: t$1.x,
				top: t$1.y,
				right: t$1.x + t$1.width,
				bottom: t$1.y + t$1.height
			});
		}
		function ni(t$1, e$1, i$1) {
			return e$1 === te ? ii(function(t$2, e$2) {
				var i$2 = ge(t$2), n$1 = $e(t$2), s$1 = i$2.visualViewport, o$1 = n$1.clientWidth, r$1 = n$1.clientHeight, a$1 = 0, l$1 = 0;
				if (s$1) {
					o$1 = s$1.width, r$1 = s$1.height;
					var c$1 = Oe();
					(c$1 || !c$1 && "fixed" === e$2) && (a$1 = s$1.offsetLeft, l$1 = s$1.offsetTop);
				}
				return {
					width: o$1,
					height: r$1,
					x: a$1 + Je(t$2),
					y: l$1
				};
			}(t$1, i$1)) : _e(e$1) ? function(t$2, e$2) {
				var i$2 = xe(t$2, !1, "fixed" === e$2);
				return i$2.top = i$2.top + t$2.clientTop, i$2.left = i$2.left + t$2.clientLeft, i$2.bottom = i$2.top + t$2.clientHeight, i$2.right = i$2.left + t$2.clientWidth, i$2.width = t$2.clientWidth, i$2.height = t$2.clientHeight, i$2.x = i$2.left, i$2.y = i$2.top, i$2;
			}(e$1, i$1) : ii(function(t$2) {
				var e$2, i$2 = $e(t$2), n$1 = Ge(t$2), s$1 = null == (e$2 = t$2.ownerDocument) ? void 0 : e$2.body, o$1 = Ae(i$2.scrollWidth, i$2.clientWidth, s$1 ? s$1.scrollWidth : 0, s$1 ? s$1.clientWidth : 0), r$1 = Ae(i$2.scrollHeight, i$2.clientHeight, s$1 ? s$1.scrollHeight : 0, s$1 ? s$1.clientHeight : 0), a$1 = -n$1.scrollLeft + Je(t$2), l$1 = -n$1.scrollTop;
				return "rtl" === Se(s$1 || i$2).direction && (a$1 += Ae(i$2.clientWidth, s$1 ? s$1.clientWidth : 0) - o$1), {
					width: o$1,
					height: r$1,
					x: a$1,
					y: l$1
				};
			}($e(t$1)));
		}
		function si(t$1) {
			var e$1, i$1 = t$1.reference, n$1 = t$1.element, s$1 = t$1.placement, o$1 = s$1 ? we(s$1) : null, r$1 = s$1 ? Be(s$1) : null, a$1 = i$1.x + i$1.width / 2 - n$1.width / 2, l$1 = i$1.y + i$1.height / 2 - n$1.height / 2;
			switch (o$1) {
				case Vt:
					e$1 = {
						x: a$1,
						y: i$1.y - n$1.height
					};
					break;
				case Kt:
					e$1 = {
						x: a$1,
						y: i$1.y + i$1.height
					};
					break;
				case Qt:
					e$1 = {
						x: i$1.x + i$1.width,
						y: l$1
					};
					break;
				case Xt:
					e$1 = {
						x: i$1.x - n$1.width,
						y: l$1
					};
					break;
				default: e$1 = {
					x: i$1.x,
					y: i$1.y
				};
			}
			var c$1 = o$1 ? je(o$1) : null;
			if (null != c$1) {
				var h$1 = "y" === c$1 ? "height" : "width";
				switch (r$1) {
					case Gt:
						e$1[c$1] = e$1[c$1] - (i$1[h$1] / 2 - n$1[h$1] / 2);
						break;
					case Jt: e$1[c$1] = e$1[c$1] + (i$1[h$1] / 2 - n$1[h$1] / 2);
				}
			}
			return e$1;
		}
		function oi(t$1, e$1) {
			void 0 === e$1 && (e$1 = {});
			var i$1 = e$1, n$1 = i$1.placement, s$1 = void 0 === n$1 ? t$1.placement : n$1, o$1 = i$1.strategy, r$1 = void 0 === o$1 ? t$1.strategy : o$1, a$1 = i$1.boundary, l$1 = void 0 === a$1 ? Zt : a$1, c$1 = i$1.rootBoundary, h$1 = void 0 === c$1 ? te : c$1, d$1 = i$1.elementContext, u$1 = void 0 === d$1 ? ee : d$1, f$1 = i$1.altBoundary, p$1 = void 0 !== f$1 && f$1, m$1 = i$1.padding, g$1 = void 0 === m$1 ? 0 : m$1, _$1 = Fe("number" != typeof g$1 ? g$1 : He(g$1, Ut)), b$1 = u$1 === ee ? ie : ee, v$1 = t$1.rects.popper, y$1 = t$1.elements[p$1 ? b$1 : u$1], w$1 = function(t$2, e$2, i$2, n$2) {
				var s$2 = "clippingParents" === e$2 ? function(t$3) {
					var e$3 = ei(Ie(t$3)), i$3 = ["absolute", "fixed"].indexOf(Se(t$3).position) >= 0 && be(t$3) ? Pe(t$3) : t$3;
					return _e(i$3) ? e$3.filter(function(t$4) {
						return _e(t$4) && Le(t$4, i$3) && "body" !== me(t$4);
					}) : [];
				}(t$2) : [].concat(e$2), o$2 = [].concat(s$2, [i$2]), r$2 = o$2[0], a$2 = o$2.reduce(function(e$3, i$3) {
					var s$3 = ni(t$2, i$3, n$2);
					return e$3.top = Ae(s$3.top, e$3.top), e$3.right = Ee(s$3.right, e$3.right), e$3.bottom = Ee(s$3.bottom, e$3.bottom), e$3.left = Ae(s$3.left, e$3.left), e$3;
				}, ni(t$2, r$2, n$2));
				return a$2.width = a$2.right - a$2.left, a$2.height = a$2.bottom - a$2.top, a$2.x = a$2.left, a$2.y = a$2.top, a$2;
			}(_e(y$1) ? y$1 : y$1.contextElement || $e(t$1.elements.popper), l$1, h$1, r$1), A$1 = xe(t$1.elements.reference), E$1 = si({
				reference: A$1,
				element: v$1,
				placement: s$1
			}), T$1 = ii(Object.assign({}, v$1, E$1)), C$1 = u$1 === ee ? T$1 : A$1, O$1 = {
				top: w$1.top - C$1.top + _$1.top,
				bottom: C$1.bottom - w$1.bottom + _$1.bottom,
				left: w$1.left - C$1.left + _$1.left,
				right: C$1.right - w$1.right + _$1.right
			}, x$1 = t$1.modifiersData.offset;
			if (u$1 === ee && x$1) {
				var k$1 = x$1[s$1];
				Object.keys(O$1).forEach(function(t$2) {
					var e$2 = [Qt, Kt].indexOf(t$2) >= 0 ? 1 : -1, i$2 = [Vt, Kt].indexOf(t$2) >= 0 ? "y" : "x";
					O$1[t$2] += k$1[i$2] * e$2;
				});
			}
			return O$1;
		}
		function ri(t$1, e$1) {
			void 0 === e$1 && (e$1 = {});
			var i$1 = e$1, n$1 = i$1.placement, s$1 = i$1.boundary, o$1 = i$1.rootBoundary, r$1 = i$1.padding, a$1 = i$1.flipVariations, l$1 = i$1.allowedAutoPlacements, c$1 = void 0 === l$1 ? se : l$1, h$1 = Be(n$1), d$1 = h$1 ? a$1 ? ne : ne.filter(function(t$2) {
				return Be(t$2) === h$1;
			}) : Ut, u$1 = d$1.filter(function(t$2) {
				return c$1.indexOf(t$2) >= 0;
			});
			0 === u$1.length && (u$1 = d$1);
			var f$1 = u$1.reduce(function(e$2, i$2) {
				return e$2[i$2] = oi(t$1, {
					placement: i$2,
					boundary: s$1,
					rootBoundary: o$1,
					padding: r$1
				})[we(i$2)], e$2;
			}, {});
			return Object.keys(f$1).sort(function(t$2, e$2) {
				return f$1[t$2] - f$1[e$2];
			});
		}
		const ai = {
			name: "flip",
			enabled: !0,
			phase: "main",
			fn: function(t$1) {
				var e$1 = t$1.state, i$1 = t$1.options, n$1 = t$1.name;
				if (!e$1.modifiersData[n$1]._skip) {
					for (var s$1 = i$1.mainAxis, o$1 = void 0 === s$1 || s$1, r$1 = i$1.altAxis, a$1 = void 0 === r$1 || r$1, l$1 = i$1.fallbackPlacements, c$1 = i$1.padding, h$1 = i$1.boundary, d$1 = i$1.rootBoundary, u$1 = i$1.altBoundary, f$1 = i$1.flipVariations, p$1 = void 0 === f$1 || f$1, m$1 = i$1.allowedAutoPlacements, g$1 = e$1.options.placement, _$1 = we(g$1), b$1 = l$1 || (_$1 !== g$1 && p$1 ? function(t$2) {
						if (we(t$2) === Yt) return [];
						var e$2 = Xe(t$2);
						return [
							Ue(t$2),
							e$2,
							Ue(e$2)
						];
					}(g$1) : [Xe(g$1)]), v$1 = [g$1].concat(b$1).reduce(function(t$2, i$2) {
						return t$2.concat(we(i$2) === Yt ? ri(e$1, {
							placement: i$2,
							boundary: h$1,
							rootBoundary: d$1,
							padding: c$1,
							flipVariations: p$1,
							allowedAutoPlacements: m$1
						}) : i$2);
					}, []), y$1 = e$1.rects.reference, w$1 = e$1.rects.popper, A$1 = /* @__PURE__ */ new Map(), E$1 = !0, T$1 = v$1[0], C$1 = 0; C$1 < v$1.length; C$1++) {
						var O$1 = v$1[C$1], x$1 = we(O$1), k$1 = Be(O$1) === Gt, L$1 = [Vt, Kt].indexOf(x$1) >= 0, S$1 = L$1 ? "width" : "height", D$1 = oi(e$1, {
							placement: O$1,
							boundary: h$1,
							rootBoundary: d$1,
							altBoundary: u$1,
							padding: c$1
						}), $$1 = L$1 ? k$1 ? Qt : Xt : k$1 ? Kt : Vt;
						y$1[S$1] > w$1[S$1] && ($$1 = Xe($$1));
						var I$1 = Xe($$1), N$1 = [];
						if (o$1 && N$1.push(D$1[x$1] <= 0), a$1 && N$1.push(D$1[$$1] <= 0, D$1[I$1] <= 0), N$1.every(function(t$2) {
							return t$2;
						})) {
							T$1 = O$1, E$1 = !1;
							break;
						}
						A$1.set(O$1, N$1);
					}
					if (E$1) for (var P$1 = function(t$2) {
						var e$2 = v$1.find(function(e$3) {
							var i$2 = A$1.get(e$3);
							if (i$2) return i$2.slice(0, t$2).every(function(t$3) {
								return t$3;
							});
						});
						if (e$2) return T$1 = e$2, "break";
					}, j$1 = p$1 ? 3 : 1; j$1 > 0 && "break" !== P$1(j$1); j$1--);
					e$1.placement !== T$1 && (e$1.modifiersData[n$1]._skip = !0, e$1.placement = T$1, e$1.reset = !0);
				}
			},
			requiresIfExists: ["offset"],
			data: { _skip: !1 }
		};
		function li(t$1, e$1, i$1) {
			return void 0 === i$1 && (i$1 = {
				x: 0,
				y: 0
			}), {
				top: t$1.top - e$1.height - i$1.y,
				right: t$1.right - e$1.width + i$1.x,
				bottom: t$1.bottom - e$1.height + i$1.y,
				left: t$1.left - e$1.width - i$1.x
			};
		}
		function ci(t$1) {
			return [
				Vt,
				Qt,
				Kt,
				Xt
			].some(function(e$1) {
				return t$1[e$1] >= 0;
			});
		}
		const hi = {
			name: "hide",
			enabled: !0,
			phase: "main",
			requiresIfExists: ["preventOverflow"],
			fn: function(t$1) {
				var e$1 = t$1.state, i$1 = t$1.name, n$1 = e$1.rects.reference, s$1 = e$1.rects.popper, o$1 = e$1.modifiersData.preventOverflow, r$1 = oi(e$1, { elementContext: "reference" }), a$1 = oi(e$1, { altBoundary: !0 }), l$1 = li(r$1, n$1), c$1 = li(a$1, s$1, o$1), h$1 = ci(l$1), d$1 = ci(c$1);
				e$1.modifiersData[i$1] = {
					referenceClippingOffsets: l$1,
					popperEscapeOffsets: c$1,
					isReferenceHidden: h$1,
					hasPopperEscaped: d$1
				}, e$1.attributes.popper = Object.assign({}, e$1.attributes.popper, {
					"data-popper-reference-hidden": h$1,
					"data-popper-escaped": d$1
				});
			}
		}, di = {
			name: "offset",
			enabled: !0,
			phase: "main",
			requires: ["popperOffsets"],
			fn: function(t$1) {
				var e$1 = t$1.state, i$1 = t$1.options, n$1 = t$1.name, s$1 = i$1.offset, o$1 = void 0 === s$1 ? [0, 0] : s$1, r$1 = se.reduce(function(t$2, i$2) {
					return t$2[i$2] = function(t$3, e$2, i$3) {
						var n$2 = we(t$3), s$2 = [Xt, Vt].indexOf(n$2) >= 0 ? -1 : 1, o$2 = "function" == typeof i$3 ? i$3(Object.assign({}, e$2, { placement: t$3 })) : i$3, r$2 = o$2[0], a$2 = o$2[1];
						return r$2 = r$2 || 0, a$2 = (a$2 || 0) * s$2, [Xt, Qt].indexOf(n$2) >= 0 ? {
							x: a$2,
							y: r$2
						} : {
							x: r$2,
							y: a$2
						};
					}(i$2, e$1.rects, o$1), t$2;
				}, {}), a$1 = r$1[e$1.placement], l$1 = a$1.x, c$1 = a$1.y;
				null != e$1.modifiersData.popperOffsets && (e$1.modifiersData.popperOffsets.x += l$1, e$1.modifiersData.popperOffsets.y += c$1), e$1.modifiersData[n$1] = r$1;
			}
		}, ui = {
			name: "popperOffsets",
			enabled: !0,
			phase: "read",
			fn: function(t$1) {
				var e$1 = t$1.state, i$1 = t$1.name;
				e$1.modifiersData[i$1] = si({
					reference: e$1.rects.reference,
					element: e$1.rects.popper,
					placement: e$1.placement
				});
			},
			data: {}
		}, fi = {
			name: "preventOverflow",
			enabled: !0,
			phase: "main",
			fn: function(t$1) {
				var e$1 = t$1.state, i$1 = t$1.options, n$1 = t$1.name, s$1 = i$1.mainAxis, o$1 = void 0 === s$1 || s$1, r$1 = i$1.altAxis, a$1 = void 0 !== r$1 && r$1, l$1 = i$1.boundary, c$1 = i$1.rootBoundary, h$1 = i$1.altBoundary, d$1 = i$1.padding, u$1 = i$1.tether, f$1 = void 0 === u$1 || u$1, p$1 = i$1.tetherOffset, m$1 = void 0 === p$1 ? 0 : p$1, g$1 = oi(e$1, {
					boundary: l$1,
					rootBoundary: c$1,
					padding: d$1,
					altBoundary: h$1
				}), _$1 = we(e$1.placement), b$1 = Be(e$1.placement), v$1 = !b$1, y$1 = je(_$1), w$1 = "x" === y$1 ? "y" : "x", A$1 = e$1.modifiersData.popperOffsets, E$1 = e$1.rects.reference, T$1 = e$1.rects.popper, C$1 = "function" == typeof m$1 ? m$1(Object.assign({}, e$1.rects, { placement: e$1.placement })) : m$1, O$1 = "number" == typeof C$1 ? {
					mainAxis: C$1,
					altAxis: C$1
				} : Object.assign({
					mainAxis: 0,
					altAxis: 0
				}, C$1), x$1 = e$1.modifiersData.offset ? e$1.modifiersData.offset[e$1.placement] : null, k$1 = {
					x: 0,
					y: 0
				};
				if (A$1) {
					if (o$1) {
						var L$1, S$1 = "y" === y$1 ? Vt : Xt, D$1 = "y" === y$1 ? Kt : Qt, $$1 = "y" === y$1 ? "height" : "width", I$1 = A$1[y$1], N$1 = I$1 + g$1[S$1], P$1 = I$1 - g$1[D$1], j$1 = f$1 ? -T$1[$$1] / 2 : 0, M$1 = b$1 === Gt ? E$1[$$1] : T$1[$$1], F$1 = b$1 === Gt ? -T$1[$$1] : -E$1[$$1], H$1 = e$1.elements.arrow, W$1 = f$1 && H$1 ? ke(H$1) : {
							width: 0,
							height: 0
						}, B$1 = e$1.modifiersData["arrow#persistent"] ? e$1.modifiersData["arrow#persistent"].padding : {
							top: 0,
							right: 0,
							bottom: 0,
							left: 0
						}, z$1 = B$1[S$1], R$1 = B$1[D$1], q$1 = Me(0, E$1[$$1], W$1[$$1]), V$1 = v$1 ? E$1[$$1] / 2 - j$1 - q$1 - z$1 - O$1.mainAxis : M$1 - q$1 - z$1 - O$1.mainAxis, K$1 = v$1 ? -E$1[$$1] / 2 + j$1 + q$1 + R$1 + O$1.mainAxis : F$1 + q$1 + R$1 + O$1.mainAxis, Q$1 = e$1.elements.arrow && Pe(e$1.elements.arrow), X$1 = Q$1 ? "y" === y$1 ? Q$1.clientTop || 0 : Q$1.clientLeft || 0 : 0, Y$1 = null != (L$1 = null == x$1 ? void 0 : x$1[y$1]) ? L$1 : 0, U$1 = I$1 + K$1 - Y$1, G$1 = Me(f$1 ? Ee(N$1, I$1 + V$1 - Y$1 - X$1) : N$1, I$1, f$1 ? Ae(P$1, U$1) : P$1);
						A$1[y$1] = G$1, k$1[y$1] = G$1 - I$1;
					}
					if (a$1) {
						var J$1, Z$1 = "x" === y$1 ? Vt : Xt, tt$1 = "x" === y$1 ? Kt : Qt, et$1 = A$1[w$1], it$1 = "y" === w$1 ? "height" : "width", nt$1 = et$1 + g$1[Z$1], st$1 = et$1 - g$1[tt$1], ot$1 = -1 !== [Vt, Xt].indexOf(_$1), rt$1 = null != (J$1 = null == x$1 ? void 0 : x$1[w$1]) ? J$1 : 0, at$1 = ot$1 ? nt$1 : et$1 - E$1[it$1] - T$1[it$1] - rt$1 + O$1.altAxis, lt$1 = ot$1 ? et$1 + E$1[it$1] + T$1[it$1] - rt$1 - O$1.altAxis : st$1, ct$1 = f$1 && ot$1 ? function(t$2, e$2, i$2) {
							var n$2 = Me(t$2, e$2, i$2);
							return n$2 > i$2 ? i$2 : n$2;
						}(at$1, et$1, lt$1) : Me(f$1 ? at$1 : nt$1, et$1, f$1 ? lt$1 : st$1);
						A$1[w$1] = ct$1, k$1[w$1] = ct$1 - et$1;
					}
					e$1.modifiersData[n$1] = k$1;
				}
			},
			requiresIfExists: ["offset"]
		};
		function pi(t$1, e$1, i$1) {
			void 0 === i$1 && (i$1 = !1);
			var n$1, s$1, o$1 = be(e$1), r$1 = be(e$1) && function(t$2) {
				var e$2 = t$2.getBoundingClientRect(), i$2 = Te(e$2.width) / t$2.offsetWidth || 1, n$2 = Te(e$2.height) / t$2.offsetHeight || 1;
				return 1 !== i$2 || 1 !== n$2;
			}(e$1), a$1 = $e(e$1), l$1 = xe(t$1, r$1, i$1), c$1 = {
				scrollLeft: 0,
				scrollTop: 0
			}, h$1 = {
				x: 0,
				y: 0
			};
			return (o$1 || !o$1 && !i$1) && (("body" !== me(e$1) || Ze(a$1)) && (c$1 = (n$1 = e$1) !== ge(n$1) && be(n$1) ? {
				scrollLeft: (s$1 = n$1).scrollLeft,
				scrollTop: s$1.scrollTop
			} : Ge(n$1)), be(e$1) ? ((h$1 = xe(e$1, !0)).x += e$1.clientLeft, h$1.y += e$1.clientTop) : a$1 && (h$1.x = Je(a$1))), {
				x: l$1.left + c$1.scrollLeft - h$1.x,
				y: l$1.top + c$1.scrollTop - h$1.y,
				width: l$1.width,
				height: l$1.height
			};
		}
		function mi(t$1) {
			var e$1 = /* @__PURE__ */ new Map(), i$1 = /* @__PURE__ */ new Set(), n$1 = [];
			function s$1(t$2) {
				i$1.add(t$2.name), [].concat(t$2.requires || [], t$2.requiresIfExists || []).forEach(function(t$3) {
					if (!i$1.has(t$3)) {
						var n$2 = e$1.get(t$3);
						n$2 && s$1(n$2);
					}
				}), n$1.push(t$2);
			}
			return t$1.forEach(function(t$2) {
				e$1.set(t$2.name, t$2);
			}), t$1.forEach(function(t$2) {
				i$1.has(t$2.name) || s$1(t$2);
			}), n$1;
		}
		var gi = {
			placement: "bottom",
			modifiers: [],
			strategy: "absolute"
		};
		function _i() {
			for (var t$1 = arguments.length, e$1 = new Array(t$1), i$1 = 0; i$1 < t$1; i$1++) e$1[i$1] = arguments[i$1];
			return !e$1.some(function(t$2) {
				return !(t$2 && "function" == typeof t$2.getBoundingClientRect);
			});
		}
		function bi(t$1) {
			void 0 === t$1 && (t$1 = {});
			var e$1 = t$1, i$1 = e$1.defaultModifiers, n$1 = void 0 === i$1 ? [] : i$1, s$1 = e$1.defaultOptions, o$1 = void 0 === s$1 ? gi : s$1;
			return function(t$2, e$2, i$2) {
				void 0 === i$2 && (i$2 = o$1);
				var s$2, r$1, a$1 = {
					placement: "bottom",
					orderedModifiers: [],
					options: Object.assign({}, gi, o$1),
					modifiersData: {},
					elements: {
						reference: t$2,
						popper: e$2
					},
					attributes: {},
					styles: {}
				}, l$1 = [], c$1 = !1, h$1 = {
					state: a$1,
					setOptions: function(i$3) {
						var s$3 = "function" == typeof i$3 ? i$3(a$1.options) : i$3;
						d$1(), a$1.options = Object.assign({}, o$1, a$1.options, s$3), a$1.scrollParents = {
							reference: _e(t$2) ? ei(t$2) : t$2.contextElement ? ei(t$2.contextElement) : [],
							popper: ei(e$2)
						};
						var r$2, c$2;
						return a$1.orderedModifiers = function(t$3) {
							var e$3 = mi(t$3);
							return pe.reduce(function(t$4, i$4) {
								return t$4.concat(e$3.filter(function(t$5) {
									return t$5.phase === i$4;
								}));
							}, []);
						}((r$2 = [].concat(n$1, a$1.options.modifiers), c$2 = r$2.reduce(function(t$3, e$3) {
							var i$4 = t$3[e$3.name];
							return t$3[e$3.name] = i$4 ? Object.assign({}, i$4, e$3, {
								options: Object.assign({}, i$4.options, e$3.options),
								data: Object.assign({}, i$4.data, e$3.data)
							}) : e$3, t$3;
						}, {}), Object.keys(c$2).map(function(t$3) {
							return c$2[t$3];
						}))).filter(function(t$3) {
							return t$3.enabled;
						}), a$1.orderedModifiers.forEach(function(t$3) {
							var e$3 = t$3.name, i$4 = t$3.options, n$2 = void 0 === i$4 ? {} : i$4, s$4 = t$3.effect;
							if ("function" == typeof s$4) {
								var o$2 = s$4({
									state: a$1,
									name: e$3,
									instance: h$1,
									options: n$2
								});
								l$1.push(o$2 || function() {});
							}
						}), h$1.update();
					},
					forceUpdate: function() {
						if (!c$1) {
							var t$3 = a$1.elements, e$3 = t$3.reference, i$3 = t$3.popper;
							if (_i(e$3, i$3)) {
								a$1.rects = {
									reference: pi(e$3, Pe(i$3), "fixed" === a$1.options.strategy),
									popper: ke(i$3)
								}, a$1.reset = !1, a$1.placement = a$1.options.placement, a$1.orderedModifiers.forEach(function(t$4) {
									return a$1.modifiersData[t$4.name] = Object.assign({}, t$4.data);
								});
								for (var n$2 = 0; n$2 < a$1.orderedModifiers.length; n$2++) if (!0 !== a$1.reset) {
									var s$3 = a$1.orderedModifiers[n$2], o$2 = s$3.fn, r$2 = s$3.options, l$2 = void 0 === r$2 ? {} : r$2, d$2 = s$3.name;
									"function" == typeof o$2 && (a$1 = o$2({
										state: a$1,
										options: l$2,
										name: d$2,
										instance: h$1
									}) || a$1);
								} else a$1.reset = !1, n$2 = -1;
							}
						}
					},
					update: (s$2 = function() {
						return new Promise(function(t$3) {
							h$1.forceUpdate(), t$3(a$1);
						});
					}, function() {
						return r$1 || (r$1 = new Promise(function(t$3) {
							Promise.resolve().then(function() {
								r$1 = void 0, t$3(s$2());
							});
						})), r$1;
					}),
					destroy: function() {
						d$1(), c$1 = !0;
					}
				};
				if (!_i(t$2, e$2)) return h$1;
				function d$1() {
					l$1.forEach(function(t$3) {
						return t$3();
					}), l$1 = [];
				}
				return h$1.setOptions(i$2).then(function(t$3) {
					!c$1 && i$2.onFirstUpdate && i$2.onFirstUpdate(t$3);
				}), h$1;
			};
		}
		var vi = bi(), yi = bi({ defaultModifiers: [
			Ke,
			ui,
			qe,
			ye
		] }), wi = bi({ defaultModifiers: [
			Ke,
			ui,
			qe,
			ye,
			di,
			ai,
			fi,
			We,
			hi
		] });
		const Ai = Object.freeze(Object.defineProperty({
			__proto__: null,
			afterMain: he,
			afterRead: ae,
			afterWrite: fe,
			applyStyles: ye,
			arrow: We,
			auto: Yt,
			basePlacements: Ut,
			beforeMain: le,
			beforeRead: oe,
			beforeWrite: de,
			bottom: Kt,
			clippingParents: Zt,
			computeStyles: qe,
			createPopper: wi,
			createPopperBase: vi,
			createPopperLite: yi,
			detectOverflow: oi,
			end: Jt,
			eventListeners: Ke,
			flip: ai,
			hide: hi,
			left: Xt,
			main: ce,
			modifierPhases: pe,
			offset: di,
			placements: se,
			popper: ee,
			popperGenerator: bi,
			popperOffsets: ui,
			preventOverflow: fi,
			read: re,
			reference: ie,
			right: Qt,
			start: Gt,
			top: Vt,
			variationPlacements: ne,
			viewport: te,
			write: ue
		}, Symbol.toStringTag, { value: "Module" })), Ei = "dropdown", Ti = ".bs.dropdown", Ci = ".data-api", Oi = "ArrowUp", xi = "ArrowDown", ki = `hide${Ti}`, Li = `hidden${Ti}`, Si = `show${Ti}`, Di = `shown${Ti}`, $i = `click${Ti}${Ci}`, Ii = `keydown${Ti}${Ci}`, Ni = `keyup${Ti}${Ci}`, Pi = "show", ji = "[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)", Mi = `${ji}.${Pi}`, Fi = ".dropdown-menu", Hi = m() ? "top-end" : "top-start", Wi = m() ? "top-start" : "top-end", Bi = m() ? "bottom-end" : "bottom-start", zi = m() ? "bottom-start" : "bottom-end", Ri = m() ? "left-start" : "right-start", qi = m() ? "right-start" : "left-start", Vi = {
			autoClose: !0,
			boundary: "clippingParents",
			display: "dynamic",
			offset: [0, 2],
			popperConfig: null,
			reference: "toggle"
		}, Ki = {
			autoClose: "(boolean|string)",
			boundary: "(string|element)",
			display: "string",
			offset: "(array|string|function)",
			popperConfig: "(null|object|function)",
			reference: "(string|element|object)"
		};
		class Qi extends B {
			constructor(t$1, e$1) {
				super(t$1, e$1), this._popper = null, this._parent = this._element.parentNode, this._menu = R.next(this._element, Fi)[0] || R.prev(this._element, Fi)[0] || R.findOne(Fi, this._parent), this._inNavbar = this._detectNavbar();
			}
			static get Default() {
				return Vi;
			}
			static get DefaultType() {
				return Ki;
			}
			static get NAME() {
				return Ei;
			}
			toggle() {
				return this._isShown() ? this.hide() : this.show();
			}
			show() {
				if (c(this._element) || this._isShown()) return;
				const t$1 = { relatedTarget: this._element };
				if (!P.trigger(this._element, Si, t$1).defaultPrevented) {
					if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t$2 of [].concat(...document.body.children)) P.on(t$2, "mouseover", d);
					this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Pi), this._element.classList.add(Pi), P.trigger(this._element, Di, t$1);
				}
			}
			hide() {
				if (c(this._element) || !this._isShown()) return;
				const t$1 = { relatedTarget: this._element };
				this._completeHide(t$1);
			}
			dispose() {
				this._popper && this._popper.destroy(), super.dispose();
			}
			update() {
				this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
			}
			_completeHide(t$1) {
				if (!P.trigger(this._element, ki, t$1).defaultPrevented) {
					if ("ontouchstart" in document.documentElement) for (const t$2 of [].concat(...document.body.children)) P.off(t$2, "mouseover", d);
					this._popper && this._popper.destroy(), this._menu.classList.remove(Pi), this._element.classList.remove(Pi), this._element.setAttribute("aria-expanded", "false"), H.removeDataAttribute(this._menu, "popper"), P.trigger(this._element, Li, t$1);
				}
			}
			_getConfig(t$1) {
				if ("object" == typeof (t$1 = super._getConfig(t$1)).reference && !r(t$1.reference) && "function" != typeof t$1.reference.getBoundingClientRect) throw new TypeError(`${Ei.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
				return t$1;
			}
			_createPopper() {
				if (void 0 === Ai) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)");
				let t$1 = this._element;
				"parent" === this._config.reference ? t$1 = this._parent : r(this._config.reference) ? t$1 = a(this._config.reference) : "object" == typeof this._config.reference && (t$1 = this._config.reference);
				const e$1 = this._getPopperConfig();
				this._popper = wi(t$1, this._menu, e$1);
			}
			_isShown() {
				return this._menu.classList.contains(Pi);
			}
			_getPlacement() {
				const t$1 = this._parent;
				if (t$1.classList.contains("dropend")) return Ri;
				if (t$1.classList.contains("dropstart")) return qi;
				if (t$1.classList.contains("dropup-center")) return "top";
				if (t$1.classList.contains("dropdown-center")) return "bottom";
				const e$1 = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
				return t$1.classList.contains("dropup") ? e$1 ? Wi : Hi : e$1 ? zi : Bi;
			}
			_detectNavbar() {
				return null !== this._element.closest(".navbar");
			}
			_getOffset() {
				const { offset: t$1 } = this._config;
				return "string" == typeof t$1 ? t$1.split(",").map((t$2) => Number.parseInt(t$2, 10)) : "function" == typeof t$1 ? (e$1) => t$1(e$1, this._element) : t$1;
			}
			_getPopperConfig() {
				const t$1 = {
					placement: this._getPlacement(),
					modifiers: [{
						name: "preventOverflow",
						options: { boundary: this._config.boundary }
					}, {
						name: "offset",
						options: { offset: this._getOffset() }
					}]
				};
				return (this._inNavbar || "static" === this._config.display) && (H.setDataAttribute(this._menu, "popper", "static"), t$1.modifiers = [{
					name: "applyStyles",
					enabled: !1
				}]), {
					...t$1,
					..._(this._config.popperConfig, [void 0, t$1])
				};
			}
			_selectMenuItem({ key: t$1, target: e$1 }) {
				const i$1 = R.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t$2) => l(t$2));
				i$1.length && v(i$1, e$1, t$1 === xi, !i$1.includes(e$1)).focus();
			}
			static jQueryInterface(t$1) {
				return this.each(function() {
					const e$1 = Qi.getOrCreateInstance(this, t$1);
					if ("string" == typeof t$1) {
						if (void 0 === e$1[t$1]) throw new TypeError(`No method named "${t$1}"`);
						e$1[t$1]();
					}
				});
			}
			static clearMenus(t$1) {
				if (2 === t$1.button || "keyup" === t$1.type && "Tab" !== t$1.key) return;
				const e$1 = R.find(Mi);
				for (const i$1 of e$1) {
					const e$2 = Qi.getInstance(i$1);
					if (!e$2 || !1 === e$2._config.autoClose) continue;
					const n$1 = t$1.composedPath(), s$1 = n$1.includes(e$2._menu);
					if (n$1.includes(e$2._element) || "inside" === e$2._config.autoClose && !s$1 || "outside" === e$2._config.autoClose && s$1) continue;
					if (e$2._menu.contains(t$1.target) && ("keyup" === t$1.type && "Tab" === t$1.key || /input|select|option|textarea|form/i.test(t$1.target.tagName))) continue;
					const o$1 = { relatedTarget: e$2._element };
					"click" === t$1.type && (o$1.clickEvent = t$1), e$2._completeHide(o$1);
				}
			}
			static dataApiKeydownHandler(t$1) {
				const e$1 = /input|textarea/i.test(t$1.target.tagName), i$1 = "Escape" === t$1.key, n$1 = [Oi, xi].includes(t$1.key);
				if (!n$1 && !i$1) return;
				if (e$1 && !i$1) return;
				t$1.preventDefault();
				const s$1 = this.matches(ji) ? this : R.prev(this, ji)[0] || R.next(this, ji)[0] || R.findOne(ji, t$1.delegateTarget.parentNode), o$1 = Qi.getOrCreateInstance(s$1);
				if (n$1) return t$1.stopPropagation(), o$1.show(), void o$1._selectMenuItem(t$1);
				o$1._isShown() && (t$1.stopPropagation(), o$1.hide(), s$1.focus());
			}
		}
		P.on(document, Ii, ji, Qi.dataApiKeydownHandler), P.on(document, Ii, Fi, Qi.dataApiKeydownHandler), P.on(document, $i, Qi.clearMenus), P.on(document, Ni, Qi.clearMenus), P.on(document, $i, ji, function(t$1) {
			t$1.preventDefault(), Qi.getOrCreateInstance(this).toggle();
		}), g(Qi);
		const Xi = "backdrop", Yi = "show", Ui = `mousedown.bs.${Xi}`, Gi = {
			className: "modal-backdrop",
			clickCallback: null,
			isAnimated: !1,
			isVisible: !0,
			rootElement: "body"
		}, Ji = {
			className: "string",
			clickCallback: "(function|null)",
			isAnimated: "boolean",
			isVisible: "boolean",
			rootElement: "(element|string)"
		};
		class Zi extends W {
			constructor(t$1) {
				super(), this._config = this._getConfig(t$1), this._isAppended = !1, this._element = null;
			}
			static get Default() {
				return Gi;
			}
			static get DefaultType() {
				return Ji;
			}
			static get NAME() {
				return Xi;
			}
			show(t$1) {
				if (!this._config.isVisible) return void _(t$1);
				this._append();
				const e$1 = this._getElement();
				this._config.isAnimated && u(e$1), e$1.classList.add(Yi), this._emulateAnimation(() => {
					_(t$1);
				});
			}
			hide(t$1) {
				this._config.isVisible ? (this._getElement().classList.remove(Yi), this._emulateAnimation(() => {
					this.dispose(), _(t$1);
				})) : _(t$1);
			}
			dispose() {
				this._isAppended && (P.off(this._element, Ui), this._element.remove(), this._isAppended = !1);
			}
			_getElement() {
				if (!this._element) {
					const t$1 = document.createElement("div");
					t$1.className = this._config.className, this._config.isAnimated && t$1.classList.add("fade"), this._element = t$1;
				}
				return this._element;
			}
			_configAfterMerge(t$1) {
				return t$1.rootElement = a(t$1.rootElement), t$1;
			}
			_append() {
				if (this._isAppended) return;
				const t$1 = this._getElement();
				this._config.rootElement.append(t$1), P.on(t$1, Ui, () => {
					_(this._config.clickCallback);
				}), this._isAppended = !0;
			}
			_emulateAnimation(t$1) {
				b(t$1, this._getElement(), this._config.isAnimated);
			}
		}
		const tn = ".bs.focustrap", en = `focusin${tn}`, nn = `keydown.tab${tn}`, sn = "backward", on = {
			autofocus: !0,
			trapElement: null
		}, rn = {
			autofocus: "boolean",
			trapElement: "element"
		};
		class an extends W {
			constructor(t$1) {
				super(), this._config = this._getConfig(t$1), this._isActive = !1, this._lastTabNavDirection = null;
			}
			static get Default() {
				return on;
			}
			static get DefaultType() {
				return rn;
			}
			static get NAME() {
				return "focustrap";
			}
			activate() {
				this._isActive || (this._config.autofocus && this._config.trapElement.focus(), P.off(document, tn), P.on(document, en, (t$1) => this._handleFocusin(t$1)), P.on(document, nn, (t$1) => this._handleKeydown(t$1)), this._isActive = !0);
			}
			deactivate() {
				this._isActive && (this._isActive = !1, P.off(document, tn));
			}
			_handleFocusin(t$1) {
				const { trapElement: e$1 } = this._config;
				if (t$1.target === document || t$1.target === e$1 || e$1.contains(t$1.target)) return;
				const i$1 = R.focusableChildren(e$1);
				0 === i$1.length ? e$1.focus() : this._lastTabNavDirection === sn ? i$1[i$1.length - 1].focus() : i$1[0].focus();
			}
			_handleKeydown(t$1) {
				"Tab" === t$1.key && (this._lastTabNavDirection = t$1.shiftKey ? sn : "forward");
			}
		}
		const ln = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", cn = ".sticky-top", hn = "padding-right", dn = "margin-right";
		class un {
			constructor() {
				this._element = document.body;
			}
			getWidth() {
				const t$1 = document.documentElement.clientWidth;
				return Math.abs(window.innerWidth - t$1);
			}
			hide() {
				const t$1 = this.getWidth();
				this._disableOverFlow(), this._setElementAttributes(this._element, hn, (e$1) => e$1 + t$1), this._setElementAttributes(ln, hn, (e$1) => e$1 + t$1), this._setElementAttributes(cn, dn, (e$1) => e$1 - t$1);
			}
			reset() {
				this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, hn), this._resetElementAttributes(ln, hn), this._resetElementAttributes(cn, dn);
			}
			isOverflowing() {
				return this.getWidth() > 0;
			}
			_disableOverFlow() {
				this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
			}
			_setElementAttributes(t$1, e$1, i$1) {
				const n$1 = this.getWidth();
				this._applyManipulationCallback(t$1, (t$2) => {
					if (t$2 !== this._element && window.innerWidth > t$2.clientWidth + n$1) return;
					this._saveInitialAttribute(t$2, e$1);
					const s$1 = window.getComputedStyle(t$2).getPropertyValue(e$1);
					t$2.style.setProperty(e$1, `${i$1(Number.parseFloat(s$1))}px`);
				});
			}
			_saveInitialAttribute(t$1, e$1) {
				const i$1 = t$1.style.getPropertyValue(e$1);
				i$1 && H.setDataAttribute(t$1, e$1, i$1);
			}
			_resetElementAttributes(t$1, e$1) {
				this._applyManipulationCallback(t$1, (t$2) => {
					const i$1 = H.getDataAttribute(t$2, e$1);
					null !== i$1 ? (H.removeDataAttribute(t$2, e$1), t$2.style.setProperty(e$1, i$1)) : t$2.style.removeProperty(e$1);
				});
			}
			_applyManipulationCallback(t$1, e$1) {
				if (r(t$1)) e$1(t$1);
				else for (const i$1 of R.find(t$1, this._element)) e$1(i$1);
			}
		}
		const fn = ".bs.modal", pn = `hide${fn}`, mn = `hidePrevented${fn}`, gn = `hidden${fn}`, _n = `show${fn}`, bn = `shown${fn}`, vn = `resize${fn}`, yn = `click.dismiss${fn}`, wn = `mousedown.dismiss${fn}`, An = `keydown.dismiss${fn}`, En = `click${fn}.data-api`, Tn = "modal-open", Cn = "show", On = "modal-static", xn = {
			backdrop: !0,
			focus: !0,
			keyboard: !0
		}, kn = {
			backdrop: "(boolean|string)",
			focus: "boolean",
			keyboard: "boolean"
		};
		class Ln extends B {
			constructor(t$1, e$1) {
				super(t$1, e$1), this._dialog = R.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new un(), this._addEventListeners();
			}
			static get Default() {
				return xn;
			}
			static get DefaultType() {
				return kn;
			}
			static get NAME() {
				return "modal";
			}
			toggle(t$1) {
				return this._isShown ? this.hide() : this.show(t$1);
			}
			show(t$1) {
				this._isShown || this._isTransitioning || P.trigger(this._element, _n, { relatedTarget: t$1 }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Tn), this._adjustDialog(), this._backdrop.show(() => this._showElement(t$1)));
			}
			hide() {
				this._isShown && !this._isTransitioning && (P.trigger(this._element, pn).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(Cn), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())));
			}
			dispose() {
				P.off(window, fn), P.off(this._dialog, fn), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
			}
			handleUpdate() {
				this._adjustDialog();
			}
			_initializeBackDrop() {
				return new Zi({
					isVisible: Boolean(this._config.backdrop),
					isAnimated: this._isAnimated()
				});
			}
			_initializeFocusTrap() {
				return new an({ trapElement: this._element });
			}
			_showElement(t$1) {
				document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
				const e$1 = R.findOne(".modal-body", this._dialog);
				e$1 && (e$1.scrollTop = 0), u(this._element), this._element.classList.add(Cn), this._queueCallback(() => {
					this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, P.trigger(this._element, bn, { relatedTarget: t$1 });
				}, this._dialog, this._isAnimated());
			}
			_addEventListeners() {
				P.on(this._element, An, (t$1) => {
					"Escape" === t$1.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
				}), P.on(window, vn, () => {
					this._isShown && !this._isTransitioning && this._adjustDialog();
				}), P.on(this._element, wn, (t$1) => {
					P.one(this._element, yn, (e$1) => {
						this._element === t$1.target && this._element === e$1.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
					});
				});
			}
			_hideModal() {
				this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
					document.body.classList.remove(Tn), this._resetAdjustments(), this._scrollBar.reset(), P.trigger(this._element, gn);
				});
			}
			_isAnimated() {
				return this._element.classList.contains("fade");
			}
			_triggerBackdropTransition() {
				if (P.trigger(this._element, mn).defaultPrevented) return;
				const t$1 = this._element.scrollHeight > document.documentElement.clientHeight, e$1 = this._element.style.overflowY;
				"hidden" === e$1 || this._element.classList.contains(On) || (t$1 || (this._element.style.overflowY = "hidden"), this._element.classList.add(On), this._queueCallback(() => {
					this._element.classList.remove(On), this._queueCallback(() => {
						this._element.style.overflowY = e$1;
					}, this._dialog);
				}, this._dialog), this._element.focus());
			}
			_adjustDialog() {
				const t$1 = this._element.scrollHeight > document.documentElement.clientHeight, e$1 = this._scrollBar.getWidth(), i$1 = e$1 > 0;
				if (i$1 && !t$1) {
					const t$2 = m() ? "paddingLeft" : "paddingRight";
					this._element.style[t$2] = `${e$1}px`;
				}
				if (!i$1 && t$1) {
					const t$2 = m() ? "paddingRight" : "paddingLeft";
					this._element.style[t$2] = `${e$1}px`;
				}
			}
			_resetAdjustments() {
				this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
			}
			static jQueryInterface(t$1, e$1) {
				return this.each(function() {
					const i$1 = Ln.getOrCreateInstance(this, t$1);
					if ("string" == typeof t$1) {
						if (void 0 === i$1[t$1]) throw new TypeError(`No method named "${t$1}"`);
						i$1[t$1](e$1);
					}
				});
			}
		}
		P.on(document, En, "[data-bs-toggle=\"modal\"]", function(t$1) {
			const e$1 = R.getElementFromSelector(this);
			["A", "AREA"].includes(this.tagName) && t$1.preventDefault(), P.one(e$1, _n, (t$2) => {
				t$2.defaultPrevented || P.one(e$1, gn, () => {
					l(this) && this.focus();
				});
			});
			const i$1 = R.findOne(".modal.show");
			i$1 && Ln.getInstance(i$1).hide(), Ln.getOrCreateInstance(e$1).toggle(this);
		}), q(Ln), g(Ln);
		const Sn = ".bs.offcanvas", Dn = ".data-api", $n = `load${Sn}${Dn}`, In = "show", Nn = "showing", Pn = "hiding", jn = ".offcanvas.show", Mn = `show${Sn}`, Fn = `shown${Sn}`, Hn = `hide${Sn}`, Wn = `hidePrevented${Sn}`, Bn = `hidden${Sn}`, zn = `resize${Sn}`, Rn = `click${Sn}${Dn}`, qn = `keydown.dismiss${Sn}`, Vn = {
			backdrop: !0,
			keyboard: !0,
			scroll: !1
		}, Kn = {
			backdrop: "(boolean|string)",
			keyboard: "boolean",
			scroll: "boolean"
		};
		class Qn extends B {
			constructor(t$1, e$1) {
				super(t$1, e$1), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
			}
			static get Default() {
				return Vn;
			}
			static get DefaultType() {
				return Kn;
			}
			static get NAME() {
				return "offcanvas";
			}
			toggle(t$1) {
				return this._isShown ? this.hide() : this.show(t$1);
			}
			show(t$1) {
				this._isShown || P.trigger(this._element, Mn, { relatedTarget: t$1 }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || new un().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Nn), this._queueCallback(() => {
					this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(In), this._element.classList.remove(Nn), P.trigger(this._element, Fn, { relatedTarget: t$1 });
				}, this._element, !0));
			}
			hide() {
				this._isShown && (P.trigger(this._element, Hn).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Pn), this._backdrop.hide(), this._queueCallback(() => {
					this._element.classList.remove(In, Pn), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new un().reset(), P.trigger(this._element, Bn);
				}, this._element, !0)));
			}
			dispose() {
				this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
			}
			_initializeBackDrop() {
				const t$1 = Boolean(this._config.backdrop);
				return new Zi({
					className: "offcanvas-backdrop",
					isVisible: t$1,
					isAnimated: !0,
					rootElement: this._element.parentNode,
					clickCallback: t$1 ? () => {
						"static" !== this._config.backdrop ? this.hide() : P.trigger(this._element, Wn);
					} : null
				});
			}
			_initializeFocusTrap() {
				return new an({ trapElement: this._element });
			}
			_addEventListeners() {
				P.on(this._element, qn, (t$1) => {
					"Escape" === t$1.key && (this._config.keyboard ? this.hide() : P.trigger(this._element, Wn));
				});
			}
			static jQueryInterface(t$1) {
				return this.each(function() {
					const e$1 = Qn.getOrCreateInstance(this, t$1);
					if ("string" == typeof t$1) {
						if (void 0 === e$1[t$1] || t$1.startsWith("_") || "constructor" === t$1) throw new TypeError(`No method named "${t$1}"`);
						e$1[t$1](this);
					}
				});
			}
		}
		P.on(document, Rn, "[data-bs-toggle=\"offcanvas\"]", function(t$1) {
			const e$1 = R.getElementFromSelector(this);
			if (["A", "AREA"].includes(this.tagName) && t$1.preventDefault(), c(this)) return;
			P.one(e$1, Bn, () => {
				l(this) && this.focus();
			});
			const i$1 = R.findOne(jn);
			i$1 && i$1 !== e$1 && Qn.getInstance(i$1).hide(), Qn.getOrCreateInstance(e$1).toggle(this);
		}), P.on(window, $n, () => {
			for (const t$1 of R.find(jn)) Qn.getOrCreateInstance(t$1).show();
		}), P.on(window, zn, () => {
			for (const t$1 of R.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t$1).position && Qn.getOrCreateInstance(t$1).hide();
		}), q(Qn), g(Qn);
		const Xn = {
			"*": [
				"class",
				"dir",
				"id",
				"lang",
				"role",
				/^aria-[\w-]*$/i
			],
			a: [
				"target",
				"href",
				"title",
				"rel"
			],
			area: [],
			b: [],
			br: [],
			col: [],
			code: [],
			dd: [],
			div: [],
			dl: [],
			dt: [],
			em: [],
			hr: [],
			h1: [],
			h2: [],
			h3: [],
			h4: [],
			h5: [],
			h6: [],
			i: [],
			img: [
				"src",
				"srcset",
				"alt",
				"title",
				"width",
				"height"
			],
			li: [],
			ol: [],
			p: [],
			pre: [],
			s: [],
			small: [],
			span: [],
			sub: [],
			sup: [],
			strong: [],
			u: [],
			ul: []
		}, Yn = new Set([
			"background",
			"cite",
			"href",
			"itemtype",
			"longdesc",
			"poster",
			"src",
			"xlink:href"
		]), Un = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, Gn = (t$1, e$1) => {
			const i$1 = t$1.nodeName.toLowerCase();
			return e$1.includes(i$1) ? !Yn.has(i$1) || Boolean(Un.test(t$1.nodeValue)) : e$1.filter((t$2) => t$2 instanceof RegExp).some((t$2) => t$2.test(i$1));
		}, Jn = {
			allowList: Xn,
			content: {},
			extraClass: "",
			html: !1,
			sanitize: !0,
			sanitizeFn: null,
			template: "<div></div>"
		}, Zn = {
			allowList: "object",
			content: "object",
			extraClass: "(string|function)",
			html: "boolean",
			sanitize: "boolean",
			sanitizeFn: "(null|function)",
			template: "string"
		}, ts = {
			entry: "(string|element|function|null)",
			selector: "(string|element)"
		};
		class es extends W {
			constructor(t$1) {
				super(), this._config = this._getConfig(t$1);
			}
			static get Default() {
				return Jn;
			}
			static get DefaultType() {
				return Zn;
			}
			static get NAME() {
				return "TemplateFactory";
			}
			getContent() {
				return Object.values(this._config.content).map((t$1) => this._resolvePossibleFunction(t$1)).filter(Boolean);
			}
			hasContent() {
				return this.getContent().length > 0;
			}
			changeContent(t$1) {
				return this._checkContent(t$1), this._config.content = {
					...this._config.content,
					...t$1
				}, this;
			}
			toHtml() {
				const t$1 = document.createElement("div");
				t$1.innerHTML = this._maybeSanitize(this._config.template);
				for (const [e$2, i$2] of Object.entries(this._config.content)) this._setContent(t$1, i$2, e$2);
				const e$1 = t$1.children[0], i$1 = this._resolvePossibleFunction(this._config.extraClass);
				return i$1 && e$1.classList.add(...i$1.split(" ")), e$1;
			}
			_typeCheckConfig(t$1) {
				super._typeCheckConfig(t$1), this._checkContent(t$1.content);
			}
			_checkContent(t$1) {
				for (const [e$1, i$1] of Object.entries(t$1)) super._typeCheckConfig({
					selector: e$1,
					entry: i$1
				}, ts);
			}
			_setContent(t$1, e$1, i$1) {
				const n$1 = R.findOne(i$1, t$1);
				n$1 && ((e$1 = this._resolvePossibleFunction(e$1)) ? r(e$1) ? this._putElementInTemplate(a(e$1), n$1) : this._config.html ? n$1.innerHTML = this._maybeSanitize(e$1) : n$1.textContent = e$1 : n$1.remove());
			}
			_maybeSanitize(t$1) {
				return this._config.sanitize ? function(t$2, e$1, i$1) {
					if (!t$2.length) return t$2;
					if (i$1 && "function" == typeof i$1) return i$1(t$2);
					const n$1 = new window.DOMParser().parseFromString(t$2, "text/html"), s$1 = [].concat(...n$1.body.querySelectorAll("*"));
					for (const t$3 of s$1) {
						const i$2 = t$3.nodeName.toLowerCase();
						if (!Object.keys(e$1).includes(i$2)) {
							t$3.remove();
							continue;
						}
						const n$2 = [].concat(...t$3.attributes), s$2 = [].concat(e$1["*"] || [], e$1[i$2] || []);
						for (const e$2 of n$2) Gn(e$2, s$2) || t$3.removeAttribute(e$2.nodeName);
					}
					return n$1.body.innerHTML;
				}(t$1, this._config.allowList, this._config.sanitizeFn) : t$1;
			}
			_resolvePossibleFunction(t$1) {
				return _(t$1, [void 0, this]);
			}
			_putElementInTemplate(t$1, e$1) {
				if (this._config.html) return e$1.innerHTML = "", void e$1.append(t$1);
				e$1.textContent = t$1.textContent;
			}
		}
		const is = new Set([
			"sanitize",
			"allowList",
			"sanitizeFn"
		]), ns = "fade", ss = "show", os = ".tooltip-inner", rs = ".modal", as = "hide.bs.modal", ls = "hover", cs = "focus", hs = "click", ds = {
			AUTO: "auto",
			TOP: "top",
			RIGHT: m() ? "left" : "right",
			BOTTOM: "bottom",
			LEFT: m() ? "right" : "left"
		}, us = {
			allowList: Xn,
			animation: !0,
			boundary: "clippingParents",
			container: !1,
			customClass: "",
			delay: 0,
			fallbackPlacements: [
				"top",
				"right",
				"bottom",
				"left"
			],
			html: !1,
			offset: [0, 6],
			placement: "top",
			popperConfig: null,
			sanitize: !0,
			sanitizeFn: null,
			selector: !1,
			template: "<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>",
			title: "",
			trigger: "hover focus"
		}, fs = {
			allowList: "object",
			animation: "boolean",
			boundary: "(string|element)",
			container: "(string|element|boolean)",
			customClass: "(string|function)",
			delay: "(number|object)",
			fallbackPlacements: "array",
			html: "boolean",
			offset: "(array|string|function)",
			placement: "(string|function)",
			popperConfig: "(null|object|function)",
			sanitize: "boolean",
			sanitizeFn: "(null|function)",
			selector: "(string|boolean)",
			template: "string",
			title: "(string|element|function)",
			trigger: "string"
		};
		class ps extends B {
			constructor(t$1, e$1) {
				if (void 0 === Ai) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)");
				super(t$1, e$1), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
			}
			static get Default() {
				return us;
			}
			static get DefaultType() {
				return fs;
			}
			static get NAME() {
				return "tooltip";
			}
			enable() {
				this._isEnabled = !0;
			}
			disable() {
				this._isEnabled = !1;
			}
			toggleEnabled() {
				this._isEnabled = !this._isEnabled;
			}
			toggle() {
				this._isEnabled && (this._isShown() ? this._leave() : this._enter());
			}
			dispose() {
				clearTimeout(this._timeout), P.off(this._element.closest(rs), as, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
			}
			show() {
				if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
				if (!this._isWithContent() || !this._isEnabled) return;
				const t$1 = P.trigger(this._element, this.constructor.eventName("show")), e$1 = (h(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
				if (t$1.defaultPrevented || !e$1) return;
				this._disposePopper();
				const i$1 = this._getTipElement();
				this._element.setAttribute("aria-describedby", i$1.getAttribute("id"));
				const { container: n$1 } = this._config;
				if (this._element.ownerDocument.documentElement.contains(this.tip) || (n$1.append(i$1), P.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i$1), i$1.classList.add(ss), "ontouchstart" in document.documentElement) for (const t$2 of [].concat(...document.body.children)) P.on(t$2, "mouseover", d);
				this._queueCallback(() => {
					P.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1;
				}, this.tip, this._isAnimated());
			}
			hide() {
				if (this._isShown() && !P.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
					if (this._getTipElement().classList.remove(ss), "ontouchstart" in document.documentElement) for (const t$1 of [].concat(...document.body.children)) P.off(t$1, "mouseover", d);
					this._activeTrigger[hs] = !1, this._activeTrigger[cs] = !1, this._activeTrigger[ls] = !1, this._isHovered = null, this._queueCallback(() => {
						this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), P.trigger(this._element, this.constructor.eventName("hidden")));
					}, this.tip, this._isAnimated());
				}
			}
			update() {
				this._popper && this._popper.update();
			}
			_isWithContent() {
				return Boolean(this._getTitle());
			}
			_getTipElement() {
				return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
			}
			_createTipElement(t$1) {
				const e$1 = this._getTemplateFactory(t$1).toHtml();
				if (!e$1) return null;
				e$1.classList.remove(ns, ss), e$1.classList.add(`bs-${this.constructor.NAME}-auto`);
				const i$1 = ((t$2) => {
					do
						t$2 += Math.floor(1e6 * Math.random());
					while (document.getElementById(t$2));
					return t$2;
				})(this.constructor.NAME).toString();
				return e$1.setAttribute("id", i$1), this._isAnimated() && e$1.classList.add(ns), e$1;
			}
			setContent(t$1) {
				this._newContent = t$1, this._isShown() && (this._disposePopper(), this.show());
			}
			_getTemplateFactory(t$1) {
				return this._templateFactory ? this._templateFactory.changeContent(t$1) : this._templateFactory = new es({
					...this._config,
					content: t$1,
					extraClass: this._resolvePossibleFunction(this._config.customClass)
				}), this._templateFactory;
			}
			_getContentForTemplate() {
				return { [os]: this._getTitle() };
			}
			_getTitle() {
				return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
			}
			_initializeOnDelegatedTarget(t$1) {
				return this.constructor.getOrCreateInstance(t$1.delegateTarget, this._getDelegateConfig());
			}
			_isAnimated() {
				return this._config.animation || this.tip && this.tip.classList.contains(ns);
			}
			_isShown() {
				return this.tip && this.tip.classList.contains(ss);
			}
			_createPopper(t$1) {
				const i$1 = ds[_(this._config.placement, [
					this,
					t$1,
					this._element
				]).toUpperCase()];
				return wi(this._element, t$1, this._getPopperConfig(i$1));
			}
			_getOffset() {
				const { offset: t$1 } = this._config;
				return "string" == typeof t$1 ? t$1.split(",").map((t$2) => Number.parseInt(t$2, 10)) : "function" == typeof t$1 ? (e$1) => t$1(e$1, this._element) : t$1;
			}
			_resolvePossibleFunction(t$1) {
				return _(t$1, [this._element, this._element]);
			}
			_getPopperConfig(t$1) {
				const e$1 = {
					placement: t$1,
					modifiers: [
						{
							name: "flip",
							options: { fallbackPlacements: this._config.fallbackPlacements }
						},
						{
							name: "offset",
							options: { offset: this._getOffset() }
						},
						{
							name: "preventOverflow",
							options: { boundary: this._config.boundary }
						},
						{
							name: "arrow",
							options: { element: `.${this.constructor.NAME}-arrow` }
						},
						{
							name: "preSetPlacement",
							enabled: !0,
							phase: "beforeMain",
							fn: (t$2) => {
								this._getTipElement().setAttribute("data-popper-placement", t$2.state.placement);
							}
						}
					]
				};
				return {
					...e$1,
					..._(this._config.popperConfig, [void 0, e$1])
				};
			}
			_setListeners() {
				const t$1 = this._config.trigger.split(" ");
				for (const e$1 of t$1) if ("click" === e$1) P.on(this._element, this.constructor.eventName("click"), this._config.selector, (t$2) => {
					const e$2 = this._initializeOnDelegatedTarget(t$2);
					e$2._activeTrigger[hs] = !(e$2._isShown() && e$2._activeTrigger[hs]), e$2.toggle();
				});
				else if ("manual" !== e$1) {
					const t$2 = e$1 === ls ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), i$1 = e$1 === ls ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
					P.on(this._element, t$2, this._config.selector, (t$3) => {
						const e$2 = this._initializeOnDelegatedTarget(t$3);
						e$2._activeTrigger["focusin" === t$3.type ? cs : ls] = !0, e$2._enter();
					}), P.on(this._element, i$1, this._config.selector, (t$3) => {
						const e$2 = this._initializeOnDelegatedTarget(t$3);
						e$2._activeTrigger["focusout" === t$3.type ? cs : ls] = e$2._element.contains(t$3.relatedTarget), e$2._leave();
					});
				}
				this._hideModalHandler = () => {
					this._element && this.hide();
				}, P.on(this._element.closest(rs), as, this._hideModalHandler);
			}
			_fixTitle() {
				const t$1 = this._element.getAttribute("title");
				t$1 && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t$1), this._element.setAttribute("data-bs-original-title", t$1), this._element.removeAttribute("title"));
			}
			_enter() {
				this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout(() => {
					this._isHovered && this.show();
				}, this._config.delay.show));
			}
			_leave() {
				this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => {
					this._isHovered || this.hide();
				}, this._config.delay.hide));
			}
			_setTimeout(t$1, e$1) {
				clearTimeout(this._timeout), this._timeout = setTimeout(t$1, e$1);
			}
			_isWithActiveTrigger() {
				return Object.values(this._activeTrigger).includes(!0);
			}
			_getConfig(t$1) {
				const e$1 = H.getDataAttributes(this._element);
				for (const t$2 of Object.keys(e$1)) is.has(t$2) && delete e$1[t$2];
				return t$1 = {
					...e$1,
					..."object" == typeof t$1 && t$1 ? t$1 : {}
				}, t$1 = this._mergeConfigObj(t$1), t$1 = this._configAfterMerge(t$1), this._typeCheckConfig(t$1), t$1;
			}
			_configAfterMerge(t$1) {
				return t$1.container = !1 === t$1.container ? document.body : a(t$1.container), "number" == typeof t$1.delay && (t$1.delay = {
					show: t$1.delay,
					hide: t$1.delay
				}), "number" == typeof t$1.title && (t$1.title = t$1.title.toString()), "number" == typeof t$1.content && (t$1.content = t$1.content.toString()), t$1;
			}
			_getDelegateConfig() {
				const t$1 = {};
				for (const [e$1, i$1] of Object.entries(this._config)) this.constructor.Default[e$1] !== i$1 && (t$1[e$1] = i$1);
				return t$1.selector = !1, t$1.trigger = "manual", t$1;
			}
			_disposePopper() {
				this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
			}
			static jQueryInterface(t$1) {
				return this.each(function() {
					const e$1 = ps.getOrCreateInstance(this, t$1);
					if ("string" == typeof t$1) {
						if (void 0 === e$1[t$1]) throw new TypeError(`No method named "${t$1}"`);
						e$1[t$1]();
					}
				});
			}
		}
		g(ps);
		const ms = ".popover-header", gs = ".popover-body", _s = {
			...ps.Default,
			content: "",
			offset: [0, 8],
			placement: "right",
			template: "<div class=\"popover\" role=\"tooltip\"><div class=\"popover-arrow\"></div><h3 class=\"popover-header\"></h3><div class=\"popover-body\"></div></div>",
			trigger: "click"
		}, bs = {
			...ps.DefaultType,
			content: "(null|string|element|function)"
		};
		class vs extends ps {
			static get Default() {
				return _s;
			}
			static get DefaultType() {
				return bs;
			}
			static get NAME() {
				return "popover";
			}
			_isWithContent() {
				return this._getTitle() || this._getContent();
			}
			_getContentForTemplate() {
				return {
					[ms]: this._getTitle(),
					[gs]: this._getContent()
				};
			}
			_getContent() {
				return this._resolvePossibleFunction(this._config.content);
			}
			static jQueryInterface(t$1) {
				return this.each(function() {
					const e$1 = vs.getOrCreateInstance(this, t$1);
					if ("string" == typeof t$1) {
						if (void 0 === e$1[t$1]) throw new TypeError(`No method named "${t$1}"`);
						e$1[t$1]();
					}
				});
			}
		}
		g(vs);
		const ys = ".bs.scrollspy", ws = `activate${ys}`, As = `click${ys}`, Es = `load${ys}.data-api`, Ts = "active", Cs = "[href]", Os = ".nav-link", xs = `${Os}, .nav-item > ${Os}, .list-group-item`, ks = {
			offset: null,
			rootMargin: "0px 0px -25%",
			smoothScroll: !1,
			target: null,
			threshold: [
				.1,
				.5,
				1
			]
		}, Ls = {
			offset: "(number|null)",
			rootMargin: "string",
			smoothScroll: "boolean",
			target: "element",
			threshold: "array"
		};
		class Ss extends B {
			constructor(t$1, e$1) {
				super(t$1, e$1), this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map(), this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
					visibleEntryTop: 0,
					parentScrollTop: 0
				}, this.refresh();
			}
			static get Default() {
				return ks;
			}
			static get DefaultType() {
				return Ls;
			}
			static get NAME() {
				return "scrollspy";
			}
			refresh() {
				this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
				for (const t$1 of this._observableSections.values()) this._observer.observe(t$1);
			}
			dispose() {
				this._observer.disconnect(), super.dispose();
			}
			_configAfterMerge(t$1) {
				return t$1.target = a(t$1.target) || document.body, t$1.rootMargin = t$1.offset ? `${t$1.offset}px 0px -30%` : t$1.rootMargin, "string" == typeof t$1.threshold && (t$1.threshold = t$1.threshold.split(",").map((t$2) => Number.parseFloat(t$2))), t$1;
			}
			_maybeEnableSmoothScroll() {
				this._config.smoothScroll && (P.off(this._config.target, As), P.on(this._config.target, As, Cs, (t$1) => {
					const e$1 = this._observableSections.get(t$1.target.hash);
					if (e$1) {
						t$1.preventDefault();
						const i$1 = this._rootElement || window, n$1 = e$1.offsetTop - this._element.offsetTop;
						if (i$1.scrollTo) return void i$1.scrollTo({
							top: n$1,
							behavior: "smooth"
						});
						i$1.scrollTop = n$1;
					}
				}));
			}
			_getNewObserver() {
				const t$1 = {
					root: this._rootElement,
					threshold: this._config.threshold,
					rootMargin: this._config.rootMargin
				};
				return new IntersectionObserver((t$2) => this._observerCallback(t$2), t$1);
			}
			_observerCallback(t$1) {
				const e$1 = (t$2) => this._targetLinks.get(`#${t$2.target.id}`), i$1 = (t$2) => {
					this._previousScrollData.visibleEntryTop = t$2.target.offsetTop, this._process(e$1(t$2));
				}, n$1 = (this._rootElement || document.documentElement).scrollTop, s$1 = n$1 >= this._previousScrollData.parentScrollTop;
				this._previousScrollData.parentScrollTop = n$1;
				for (const o$1 of t$1) {
					if (!o$1.isIntersecting) {
						this._activeTarget = null, this._clearActiveClass(e$1(o$1));
						continue;
					}
					const t$2 = o$1.target.offsetTop >= this._previousScrollData.visibleEntryTop;
					if (s$1 && t$2) {
						if (i$1(o$1), !n$1) return;
					} else s$1 || t$2 || i$1(o$1);
				}
			}
			_initializeTargetsAndObservables() {
				this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map();
				const t$1 = R.find(Cs, this._config.target);
				for (const e$1 of t$1) {
					if (!e$1.hash || c(e$1)) continue;
					const t$2 = R.findOne(decodeURI(e$1.hash), this._element);
					l(t$2) && (this._targetLinks.set(decodeURI(e$1.hash), e$1), this._observableSections.set(e$1.hash, t$2));
				}
			}
			_process(t$1) {
				this._activeTarget !== t$1 && (this._clearActiveClass(this._config.target), this._activeTarget = t$1, t$1.classList.add(Ts), this._activateParents(t$1), P.trigger(this._element, ws, { relatedTarget: t$1 }));
			}
			_activateParents(t$1) {
				if (t$1.classList.contains("dropdown-item")) R.findOne(".dropdown-toggle", t$1.closest(".dropdown")).classList.add(Ts);
				else for (const e$1 of R.parents(t$1, ".nav, .list-group")) for (const t$2 of R.prev(e$1, xs)) t$2.classList.add(Ts);
			}
			_clearActiveClass(t$1) {
				t$1.classList.remove(Ts);
				const e$1 = R.find(`${Cs}.${Ts}`, t$1);
				for (const t$2 of e$1) t$2.classList.remove(Ts);
			}
			static jQueryInterface(t$1) {
				return this.each(function() {
					const e$1 = Ss.getOrCreateInstance(this, t$1);
					if ("string" == typeof t$1) {
						if (void 0 === e$1[t$1] || t$1.startsWith("_") || "constructor" === t$1) throw new TypeError(`No method named "${t$1}"`);
						e$1[t$1]();
					}
				});
			}
		}
		P.on(window, Es, () => {
			for (const t$1 of R.find("[data-bs-spy=\"scroll\"]")) Ss.getOrCreateInstance(t$1);
		}), g(Ss);
		const Ds = ".bs.tab", $s = `hide${Ds}`, Is = `hidden${Ds}`, Ns = `show${Ds}`, Ps = `shown${Ds}`, js = `click${Ds}`, Ms = `keydown${Ds}`, Fs = `load${Ds}`, Hs = "ArrowLeft", Ws = "ArrowRight", Bs = "ArrowUp", zs = "ArrowDown", Rs = "Home", qs = "End", Vs = "active", Ks = "fade", Qs = "show", Xs = ".dropdown-toggle", Ys = `:not(${Xs})`, Us = "[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]", Gs = `.nav-link${Ys}, .list-group-item${Ys}, [role="tab"]${Ys}, ${Us}`, Js = `.${Vs}[data-bs-toggle="tab"], .${Vs}[data-bs-toggle="pill"], .${Vs}[data-bs-toggle="list"]`;
		class Zs extends B {
			constructor(t$1) {
				super(t$1), this._parent = this._element.closest(".list-group, .nav, [role=\"tablist\"]"), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), P.on(this._element, Ms, (t$2) => this._keydown(t$2)));
			}
			static get NAME() {
				return "tab";
			}
			show() {
				const t$1 = this._element;
				if (this._elemIsActive(t$1)) return;
				const e$1 = this._getActiveElem(), i$1 = e$1 ? P.trigger(e$1, $s, { relatedTarget: t$1 }) : null;
				P.trigger(t$1, Ns, { relatedTarget: e$1 }).defaultPrevented || i$1 && i$1.defaultPrevented || (this._deactivate(e$1, t$1), this._activate(t$1, e$1));
			}
			_activate(t$1, e$1) {
				t$1 && (t$1.classList.add(Vs), this._activate(R.getElementFromSelector(t$1)), this._queueCallback(() => {
					"tab" === t$1.getAttribute("role") ? (t$1.removeAttribute("tabindex"), t$1.setAttribute("aria-selected", !0), this._toggleDropDown(t$1, !0), P.trigger(t$1, Ps, { relatedTarget: e$1 })) : t$1.classList.add(Qs);
				}, t$1, t$1.classList.contains(Ks)));
			}
			_deactivate(t$1, e$1) {
				t$1 && (t$1.classList.remove(Vs), t$1.blur(), this._deactivate(R.getElementFromSelector(t$1)), this._queueCallback(() => {
					"tab" === t$1.getAttribute("role") ? (t$1.setAttribute("aria-selected", !1), t$1.setAttribute("tabindex", "-1"), this._toggleDropDown(t$1, !1), P.trigger(t$1, Is, { relatedTarget: e$1 })) : t$1.classList.remove(Qs);
				}, t$1, t$1.classList.contains(Ks)));
			}
			_keydown(t$1) {
				if (![
					Hs,
					Ws,
					Bs,
					zs,
					Rs,
					qs
				].includes(t$1.key)) return;
				t$1.stopPropagation(), t$1.preventDefault();
				const e$1 = this._getChildren().filter((t$2) => !c(t$2));
				let i$1;
				if ([Rs, qs].includes(t$1.key)) i$1 = e$1[t$1.key === Rs ? 0 : e$1.length - 1];
				else {
					const n$1 = [Ws, zs].includes(t$1.key);
					i$1 = v(e$1, t$1.target, n$1, !0);
				}
				i$1 && (i$1.focus({ preventScroll: !0 }), Zs.getOrCreateInstance(i$1).show());
			}
			_getChildren() {
				return R.find(Gs, this._parent);
			}
			_getActiveElem() {
				return this._getChildren().find((t$1) => this._elemIsActive(t$1)) || null;
			}
			_setInitialAttributes(t$1, e$1) {
				this._setAttributeIfNotExists(t$1, "role", "tablist");
				for (const t$2 of e$1) this._setInitialAttributesOnChild(t$2);
			}
			_setInitialAttributesOnChild(t$1) {
				t$1 = this._getInnerElement(t$1);
				const e$1 = this._elemIsActive(t$1), i$1 = this._getOuterElement(t$1);
				t$1.setAttribute("aria-selected", e$1), i$1 !== t$1 && this._setAttributeIfNotExists(i$1, "role", "presentation"), e$1 || t$1.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t$1, "role", "tab"), this._setInitialAttributesOnTargetPanel(t$1);
			}
			_setInitialAttributesOnTargetPanel(t$1) {
				const e$1 = R.getElementFromSelector(t$1);
				e$1 && (this._setAttributeIfNotExists(e$1, "role", "tabpanel"), t$1.id && this._setAttributeIfNotExists(e$1, "aria-labelledby", `${t$1.id}`));
			}
			_toggleDropDown(t$1, e$1) {
				const i$1 = this._getOuterElement(t$1);
				if (!i$1.classList.contains("dropdown")) return;
				const n$1 = (t$2, n$2) => {
					const s$1 = R.findOne(t$2, i$1);
					s$1 && s$1.classList.toggle(n$2, e$1);
				};
				n$1(Xs, Vs), n$1(".dropdown-menu", Qs), i$1.setAttribute("aria-expanded", e$1);
			}
			_setAttributeIfNotExists(t$1, e$1, i$1) {
				t$1.hasAttribute(e$1) || t$1.setAttribute(e$1, i$1);
			}
			_elemIsActive(t$1) {
				return t$1.classList.contains(Vs);
			}
			_getInnerElement(t$1) {
				return t$1.matches(Gs) ? t$1 : R.findOne(Gs, t$1);
			}
			_getOuterElement(t$1) {
				return t$1.closest(".nav-item, .list-group-item") || t$1;
			}
			static jQueryInterface(t$1) {
				return this.each(function() {
					const e$1 = Zs.getOrCreateInstance(this);
					if ("string" == typeof t$1) {
						if (void 0 === e$1[t$1] || t$1.startsWith("_") || "constructor" === t$1) throw new TypeError(`No method named "${t$1}"`);
						e$1[t$1]();
					}
				});
			}
		}
		P.on(document, js, Us, function(t$1) {
			["A", "AREA"].includes(this.tagName) && t$1.preventDefault(), c(this) || Zs.getOrCreateInstance(this).show();
		}), P.on(window, Fs, () => {
			for (const t$1 of R.find(Js)) Zs.getOrCreateInstance(t$1);
		}), g(Zs);
		const to = ".bs.toast", eo = `mouseover${to}`, io = `mouseout${to}`, no = `focusin${to}`, so = `focusout${to}`, oo = `hide${to}`, ro = `hidden${to}`, ao = `show${to}`, lo = `shown${to}`, co = "hide", ho = "show", uo = "showing", fo = {
			animation: "boolean",
			autohide: "boolean",
			delay: "number"
		}, po = {
			animation: !0,
			autohide: !0,
			delay: 5e3
		};
		class mo extends B {
			constructor(t$1, e$1) {
				super(t$1, e$1), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
			}
			static get Default() {
				return po;
			}
			static get DefaultType() {
				return fo;
			}
			static get NAME() {
				return "toast";
			}
			show() {
				P.trigger(this._element, ao).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(co), u(this._element), this._element.classList.add(ho, uo), this._queueCallback(() => {
					this._element.classList.remove(uo), P.trigger(this._element, lo), this._maybeScheduleHide();
				}, this._element, this._config.animation));
			}
			hide() {
				this.isShown() && (P.trigger(this._element, oo).defaultPrevented || (this._element.classList.add(uo), this._queueCallback(() => {
					this._element.classList.add(co), this._element.classList.remove(uo, ho), P.trigger(this._element, ro);
				}, this._element, this._config.animation)));
			}
			dispose() {
				this._clearTimeout(), this.isShown() && this._element.classList.remove(ho), super.dispose();
			}
			isShown() {
				return this._element.classList.contains(ho);
			}
			_maybeScheduleHide() {
				this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
					this.hide();
				}, this._config.delay)));
			}
			_onInteraction(t$1, e$1) {
				switch (t$1.type) {
					case "mouseover":
					case "mouseout":
						this._hasMouseInteraction = e$1;
						break;
					case "focusin":
					case "focusout": this._hasKeyboardInteraction = e$1;
				}
				if (e$1) return void this._clearTimeout();
				const i$1 = t$1.relatedTarget;
				this._element === i$1 || this._element.contains(i$1) || this._maybeScheduleHide();
			}
			_setListeners() {
				P.on(this._element, eo, (t$1) => this._onInteraction(t$1, !0)), P.on(this._element, io, (t$1) => this._onInteraction(t$1, !1)), P.on(this._element, no, (t$1) => this._onInteraction(t$1, !0)), P.on(this._element, so, (t$1) => this._onInteraction(t$1, !1));
			}
			_clearTimeout() {
				clearTimeout(this._timeout), this._timeout = null;
			}
			static jQueryInterface(t$1) {
				return this.each(function() {
					const e$1 = mo.getOrCreateInstance(this, t$1);
					if ("string" == typeof t$1) {
						if (void 0 === e$1[t$1]) throw new TypeError(`No method named "${t$1}"`);
						e$1[t$1](this);
					}
				});
			}
		}
		return q(mo), g(mo), {
			Alert: X,
			Button: U,
			Carousel: St,
			Collapse: qt,
			Dropdown: Qi,
			Modal: Ln,
			Offcanvas: Qn,
			Popover: vs,
			ScrollSpy: Ss,
			Tab: Zs,
			Toast: mo,
			Tooltip: ps
		};
	});
}) });

//#endregion
export default require_bootstrap_bundle_min();

//# sourceMappingURL=bootstrap_dist_js_bootstrap__bundle__min__js.js.map